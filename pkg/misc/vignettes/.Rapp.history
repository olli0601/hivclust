i<- 1#
		cat('\nprocess ',infiles[i,FIN],'\nprocess ',infiles[i,FLABEL])#
		infile <- infiles[i,FIN]#
		ph <- read.tree(infile)#
		ph$node.label <- NULL#
		#	update tip labels: add world region to start of label#
		local.world.region <- gsub('^.*_labels_([A-Z]+)\\.csv$','\\1', basename(infiles[i,FLABEL]))#
		dl <- as.data.table(read.csv(infiles[i,FLABEL], stringsAsFactors=FALSE))#
		dl[, X:=NULL]	#
		stopifnot(!any(ph$tip.label==''))#
		dp <- data.table(IDX=1:Ntip(ph), TAXA=ph$tip.label)#
		dp <- merge(dp,dl,by='TAXA',all.x=TRUE)#
		stopifnot( nrow(dp[is.na(TAXA_NEW),])==0 )#
		stopifnot( !any(duplicated(ph$tip.label)) )#
		ph$tip.label <- dp[order(IDX),][, TAXA_NEW]#
		#	re-root#
		tmp <- dp[, list(NST=length(TAXA)), by='ST']#
		tmp <- tmp[order(-NST),][2,ST]#
		tmp <- subset(dp, ST==tmp,)[,TAXA_NEW]#
		root <- getMRCA(ph, tmp)#
		ph <- reroot(ph, root, ph$edge.length[which(ph$edge[,2]==root)]/2)#
		#	drop other subtypes#
		tmp <- dp[, list(NST=length(TAXA)), by='ST']#
		tmp <- tmp[order(-NST),][-1,ST]#
		tmp <- subset(dp, ST%in%tmp,)[,TAXA_NEW]#
		ph <- drop.tip(ph, tmp)
split.phs <- list()#
			repeat({#
					local.tips <- which(grepl(paste0('^',local.world.region),ph$tip.label))#
					local.tip.ancestors <- Ancestors(ph, sample(local.tips,1))#
					cat('\nNumer of local tips left to divide into smaller trees, n=', length(local.tips))#
					subtree.mrca <- Ntip(ph)+1L#
					for(k in seq_along(local.tip.ancestors))#
					{				#
						tmp <- length(Descendants(ph, local.tip.ancestors[k], type='tips')[[1]])#
						#print(tmp)#
						if(tmp>max.Ntip)#
						{#
							subtree.mrca <- local.tip.ancestors[k-1]#
							break#
						}#
					}					#
					if(subtree.mrca>Ntip(ph))#
					{#
						split.phs[[length(split.phs)+1L]] <- extract.clade(ph, subtree.mrca)#
						if(length(split.phs[[length(split.phs)]][['tip.label']])==Ntip(ph))#
							break#
						ph <- drop.tip(ph, split.phs[[length(split.phs)]][['tip.label']])						#
					}#
				})
split.phs
isInf(3)
is.inf(3)
infinity(3)
Infinity(3)
Inf
str(Inf)
infile
length(split.phs)
for(k in seq_along(split.phs))#
			{#
				intree.phsc <- gsub('_(Subtype[A-Za-z0-9]+)_',paste0('_\\1c',k,'_'),gsub('\\.newick',paste0('_rerooted_',local.world.region,'.newick'),basename(infile)))#
				intree.phsc <- file.path(outdir,intree.phsc)#
			}				#
			write.tree(split.phs[[k]], file=intree.phsc)#
			if(plot.phylogenies)#
			{#
				pdf(file=gsub('newick','pdf',intree.phsc), w=20, h=10+Ntip(split.phs[[k]])/10)#
				plot(split.phs[[k]], show.node.label=TRUE, cex=0.3)#
				dev.off()			#
			}
plot.phylogenies<- 1
for(k in seq_along(split.phs))#
			{#
				intree.phsc <- gsub('_(Subtype[A-Za-z0-9]+)_',paste0('_\\1c',k,'_'),gsub('\\.newick',paste0('_rerooted_',local.world.region,'.newick'),basename(infile)))#
				intree.phsc <- file.path(outdir,intree.phsc)#
				write.tree(split.phs[[k]], file=intree.phsc)#
				if(plot.phylogenies)#
				{#
					pdf(file=gsub('newick','pdf',intree.phsc), w=20, h=10+Ntip(split.phs[[k]])/10)#
					plot(split.phs[[k]], show.node.label=TRUE, cex=0.3)#
					dev.off()			#
				}#
			}
outdir
infiles <- data.table(FIN=list.files(outdir, pattern='\\.newick$',full.names=TRUE))#
	infiles[, ST:= gsub('.*_Subtype([A-Z0-9]+)_.*','\\1',basename(FIN))]
infiles
infiles <- data.table(FIN=list.files(outdir, pattern='\\.newick$',full.names=TRUE))#
	infiles[, ST:= gsub('.*_Subtype([A-Z0-9]+)_.*','\\1',basename(FIN))]	#
	infiles <- subset(infiles, gsub('SubtypeBc[0-9]+',ST))
infiles <- subset(infiles, grepl('SubtypeBc[0-9]+',ST))
infiles
infiles <- data.table(FIN=list.files(outdir, pattern='\\.newick$',full.names=TRUE))#
	infiles[, ST:= gsub('.*_Subtype([A-Za-z0-9]+)_.*','\\1',basename(FIN))]	#
	infiles <- subset(infiles, grepl('SubtypeBc[0-9]+',ST))
infiles
infiles <- data.table(FIN=list.files(outdir, pattern='\\.newick$',full.names=TRUE))#
	infiles[, ST:= gsub('^.*_Subtype([A-Za-z0-9]+)_.*$','\\1',basename(FIN))]
infiles
infiles <- subset(infiles, grepl('SubtypeBc[0-9]+',ST))
infiles
infiles <- data.table(FIN=list.files(outdir, pattern='\\.newick$',full.names=TRUE))#
	infiles[, ST:= gsub('^.*_Subtype([A-Za-z0-9]+)_.*$','\\1',basename(FIN))]
infiles[, table(ST)]
infiles <- subset(infiles, grepl('Bc[0-9]+',ST))
infiles
infiles <- data.table(FIN=list.files(outdir, pattern='\\.newick$',full.names=TRUE))#
	infiles[, ST:= gsub('^.*_Subtype([A-Za-z0-9]+)_.*$','\\1',basename(FIN))]	#
	infiles <- subset(infiles, grepl('Bc[0-9]+',ST))#
	cmds <- vector('list',nrow(infiles))	#
	for(i in seq_len(nrow(infiles)))#
	{				#
		# 	make phyloscanner UNIX command#
		infile <- infiles[i,FIN]#
		outputString <- paste0(gsub('\\.newick','_',infile))#
		tip.regex <- "^([A-Za-z]+)___.*$"#
		cmd <- paste("CWD=$(pwd)\n",sep='')#
		cmd <- paste(cmd,"echo $CWD\n",sep='')	#
		tmpdir.prefix <- paste('phsc_',format(Sys.time(),"%y-%m-%d-%H-%M-%S"),sep='')#
		tmpdir <- paste("$CWD/",tmpdir.prefix,sep='')#
		tmp.in <- file.path(tmpdir, basename(infile))#
		cmd <- paste(cmd,"mkdir -p ",tmpdir,'\n',sep='')#
		cmd <- paste(cmd,'cp "',infile,'" ',tmp.in,'\n', sep='')#
		cmd <- paste(cmd,'cd ', tmpdir,'\n', sep='')#
		cmd <- paste0(cmd,'Rscript ',prog.phyloscanner_analyse_trees,' ',basename(infile),' ',basename(outputString))	#
		cmd <- paste0(cmd,' s,0 -m 1e-5 -x "',tip.regex,'" -v 1 -ow -rda\n')#
		cmd <- paste0(cmd,'mv ',basename(outputString),'* ','"',dirname(outputString),'"','\n')	#
		cmd <- paste(cmd, "cd $CWD\n",sep='')#
		cmd <- paste(cmd, "rm ", tmpdir,'\n',sep='')#
		cmds[[i]] <- cmd#
	}#
	infiles[, CMD:= unlist(cmds)]	#
	#	submit jobs like this one:#
	cat(infiles[1,CMD])
96/8
require(data.table)#
	require(tidyverse)#
	require(ape)#
	require(phytools)#
	require(treedater)#
	home <- '~/Box Sync/OR_Work/Seattle'#
	infile.seqinfo <- file.path(home,'PHSKC-2018-07-09','sequences_meta.rds')	#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	infiles.phsc <- data.table(F=list.files(indir.phsc, pattern='workspace.rda$', full.names=TRUE, recursive=TRUE))
infiles.phsc
alignment.length <- 1000#
	##
	# read Seattle sampling data #
	##
	dseq <- readRDS(infile.seqinfo) #
	dseq <- dseq %>% #
			select(seqID, newnum, type, seqy, seqm) %>%#
			mutate( SEQ_DATE:= seqy + (seqm-1)/12 + 15/365,#
					SEQ_DATE_LOWER:= seqy + (seqm-1)/12,#
					SEQ_DATE_UPPER:= seqy + (seqm-1)/12 + 30/365#
					) %>%#
			select(-seqy, -seqm) %>%#
			rename(TAXA= seqID, PID= newnum, TYPE=type)#
	dseq <- as.data.table(dseq)
dseq
subset(infiles.phsc, grepl('000',F))
infiles.phsc <- subset(infiles.phsc, grepl('000',F))
alignment.length <- 1000#
	##
	# read Seattle sampling data #
	##
	dseq <- readRDS(infile.seqinfo) #
	dseq <- dseq %>% #
			select(seqID, newnum, type, seqy, seqm) %>%#
			mutate( SEQ_DATE:= seqy + (seqm-1)/12 + 15/365,#
					SEQ_DATE_LOWER:= seqy + (seqm-1)/12,#
					SEQ_DATE_UPPER:= seqy + (seqm-1)/12 + 30/365#
					) %>%#
			select(-seqy, -seqm) %>%#
			rename(TAXA= seqID, PID= newnum, TYPE=type)#
	dseq <- as.data.table(dseq)
i<- 1
infile <- infiles.phsc[i,F]	#
		load(infile)#
		ph <- phyloscanner.trees[[1]][['tree']]#
		stopifnot( !any( ph$tip.label=='' ) )#
		##
		#	drop tips without sequence dates, #
		#	while conserving the ancestral state reconstructions#
		##
		#	extract taxa names#
		dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		#	add Seattle sequence dates#
		dph <- merge(dph, dseq, by='TAXA', all.x=TRUE)#
		#	extract GenBank sequence dates from taxa names where possible #
		dph[, GENBANK_ID:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\5',TAXA)]#
		dph[, GENBANK_SEQDATE:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\3',TAXA)]#
		set(dph, dph[, which(GENBANK_SEQDATE=='-' | !is.na(SEQ_DATE))],'GENBANK_SEQDATE',NA_character_)	#
		set(dph, NULL, 'GENBANK_SEQDATE_LOWER', dph[, as.numeric(GENBANK_SEQDATE) ])#
		set(dph, NULL, 'GENBANK_SEQDATE_UPPER', dph[, as.numeric(GENBANK_SEQDATE) + 364/365 ])	#
		set(dph, NULL, 'GENBANK_SEQDATE', dph[, as.numeric(GENBANK_SEQDATE) + 1/2 ])#
		tmp <- dph[, which(is.na(SEQ_DATE))]#
		set(dph, tmp, 'SEQ_DATE', dph[tmp, GENBANK_SEQDATE])#
		set(dph, tmp, 'SEQ_DATE_LOWER', dph[tmp, GENBANK_SEQDATE_LOWER])#
		set(dph, tmp, 'SEQ_DATE_UPPER', dph[tmp, GENBANK_SEQDATE_UPPER])#
		set(dph, NULL, c('GENBANK_SEQDATE','GENBANK_SEQDATE_LOWER','GENBANK_SEQDATE_UPPER'), NULL)	#
		#	drop tips #
		dph.old <- subset(dph, select=c(TAXA, SEQ_DATE, SEQ_DATE_LOWER, SEQ_DATE_UPPER))	#
		tmp <- subset(dph, is.na(SEQ_DATE))[, TAXA_ID]#
		cat('Dropping tips without sampling date from ', infile,' n=', length(tmp), 'of Ntips=', Ntip(ph), '\n')
phyloscanner.to.simmap(ph)
# Get the tip number of this label#
#
#' @keywords internal#
#' @export get.tip.no#
#
get.tip.no <- function(tree, name) {#
  return(match(name, tree$tip.label))#
}#
#
# Get all tips associated with a host#
#
#' @keywords internal#
#' @export get.tips.for.host#
#
get.tips.for.host <- function(tree, host.string, host.ids, blacklist) {#
  node.numbers <- which(grepl(paste0('^',host.string),host.ids))#
  node.numbers <-#
    node.numbers[which(!(node.numbers %in% blacklist))]#
  return(node.numbers)#
}#
#
#' @keywords internal#
#' @export get.tips.for.sample#
#
get.tips.for.sample <- function(tree, sample.string){#
  return(which(grepl(paste0('^',sample.string),tree$tip.label)))#
}#
#
# Edge length by node number (probably in some library somewhere)#
#
#' @keywords internal#
#' @export get.edge.length#
#
get.edge.length <- function(tree, node) {#
  index <- which(tree$edge[,2] == node)#
  return(tree$edge.length[index])#
}#
#
# Node is a tip (likewise)#
#
#' @keywords internal#
#' @export is.tip#
#
is.tip <- function(tree, node) {#
  return(node <= length(tree$tip.label))#
}#
#
# Node is root (likewise)#
#
#' @keywords internal#
#' @export is.root#
#
is.root <- function(tree, node) {#
  return(Ancestors(tree, node, type = "parent") == 0)#
}#
#
# Get the sequence of ancestors from one node to the other#
#
#' @keywords internal#
#' @export get.ancestral.sequence#
#
get.ancestral.sequence <- function(tree, desc, anc) {#
  if (!(anc %in% Ancestors(tree, desc, type = "all"))) {#
    stop("anc is not an ancestor of desc at all")#
  }#
  current <- desc#
  out <- desc#
  while (current != anc) {#
    current <- Ancestors(tree, current, type = "parent")#
    out <- c(out, current)#
  }#
  return(out)#
}#
#
# Output the host that this tip belongs to. The vector host.ids #
# records hosts in the same order as the tips in the tree#
#
#' @keywords internal#
#' @export get.host.from.tip#
#
get.host.from.tip <- function(tree, node, host.ids) {#
  # is it a tip?#
  if (!(is.tip(tree, node))) {#
    stop("Not a tip")#
  }#
  host.id <- host.ids[node]#
  return(host.id)#
}#
#
# Output the set of hosts whose tips are descended from a node #
# (or the host of the node itself if a tip)#
#
#' @keywords internal#
#' @export get.hosts.from.this.clade#
#
get.hosts.from.this.clade <- function(tree, node, host.ids) {#
  if (is.tip(tree,node)) {#
    return(get.host.from.tip(tree, node, host.ids))#
  }#
  out <- vector()#
  tips <- Descendants(tree, node, type = "tips")[[1]]#
  for (tip in tips) {#
    if (!(get.host.from.tip(tree,tip) %in% out)) {#
      out <- c(out, get.host.from.tip(tree, tip, host.ids))#
    }#
  }#
  return(out)#
}#
#
# Is desc _unambiguously_ a descendant of anc? I.e. is the MRCA node of desc #
# a descendant of the MRCA node of anc, but no tips of anc are descended from#
# the MRCA node of desc?#
# mrca.list is a list of MRCA nodes indexed by host#
# tip.list is a list of vectors of tips indexed by host#
#
#' @keywords internal#
#' @export is.descendant.of#
#
is.descendant.of <- function(tree, desc, anc, mrca.list, tip.list) {#
  mrca.desc <- mrca.list[[desc]]#
  mrca.anc <- mrca.list[[anc]]#
  if (!(mrca.anc %in% Ancestors(tree, mrca.desc, type = "all"))) {#
    return(FALSE)#
  } else {#
    for (tip in tip.list[[anc]]) {#
      if (mrca.desc %in% Ancestors(tree, tip, type = "all")) {#
        return(FALSE)#
      }#
    }#
  }#
  return(TRUE)#
}#
#
# Is the intersection between vectors x and y empty?#
#
#' @keywords internal#
#' @export nonempty.intersection#
#
nonempty.intersection <- function(x,y) {#
  return(length(intersect(x,y)) > 0)#
}#
#
# Returns whether the tips corresponding to hosts pat.1 and pat.2 are intermingled#
# in tree, i.e. if the MRCA of one set is both descended from (or equal to) the MRCA of #
# the other and an ancestor of at least one tip from the other#
# mrca.list is a list of MRCA nodes indexed by host#
# tip.list is a list of vectors of tips indexed by host#
#
#' @keywords internal#
#' @export are.intermingled#
#
are.intermingled <-#
  function(tree, pat.1, pat.2, mrca.list, tip.list) {#
    mrca.1 <- mrca.list[[pat.1]]#
    mrca.2 <- mrca.list[[pat.2]]#
    if (mrca.1 == mrca.2) {#
      return(TRUE)#
    }#
    if ((mrca.1 %in% Ancestors(tree, mrca.2, type = "all"))) {#
      for (tip in tip.list[[pat.1]]) {#
        if (mrca.2 %in% Ancestors(tree, tip, type = "all")) {#
          return(TRUE)#
        }#
      }#
    }#
    if ((mrca.2 %in% Ancestors(tree, mrca.1, type = "all"))) {#
      for (tip in tip.list[[pat.2]]) {#
        if (mrca.1 %in% Ancestors(tree, tip, type = "all")) {#
          return(TRUE)#
        }#
      }#
    }#
    return(FALSE)#
  }#
#
# Output the set of hosts whose mrca is this node#
#
#' @keywords internal#
#' @export get.hosts.with.these.mrcas#
#
get.hosts.with.these.mrcas <-#
  function(tree, node, host.mrcas) {#
    out <- vector()#
    mrca.vec <- sapply(host.mrcas, "[[", 1)#
    numbers <- which(mrca.vec == node)#
    return(names(numbers))#
  }#
#
# Get the distance between the MRCA nodes of these two hosts#
#
#' @keywords internal#
#' @export get.mrca.distance#
#
get.mrca.distance <- function(tree, pat.1, pat.2, mrca.list) {#
  mrca.1 <- mrca.list[[pat.1]]#
  mrca.2 <- mrca.list[[pat.2]]#
  return(total.length.between(tree, mrca.1, mrca.2))#
}#
#
# Get the distance between these two nodes#
#
#' @keywords internal#
#' @export total.length.between#
#
total.length.between <- function(tree, node.1, node.2) {#
  if (node.1 == node.2) {#
    return(0)#
  }#
  total.length <- 0#
  if (node.1 %in% Descendants(tree, node.2, type = "all")) {#
    current.node <- node.1#
    while (current.node != node.2) {#
      total.length <- total.length + get.edge.length(tree, current.node)#
      current.node <- Ancestors(tree, current.node, type = "parent")#
    }#
    return(total.length)#
  } else if (node.2 %in% Descendants(tree, node.1, type = "all")) {#
    current.node <- node.2#
    while (current.node != node.1) {#
      total.length <- total.length + get.edge.length(tree, current.node)#
      current.node <- Ancestors(tree, current.node, type = "parent")#
    }#
    return(total.length)#
  } else {#
    joint.mrca <- mrca.phylo(tree, c(node.1, node.2))#
    return(#
      total.length.between(tree, node.1, joint.mrca) + total.length.between(tree, node.2, joint.mrca)#
    )#
  }#
}#
#
# mrca.phylo applied to a tip only will not return that tip. This function will.#
#
#' @keywords internal#
#' @export mrca.phylo.or.unique.tip#
#
mrca.phylo.or.unique.tip <-#
  function(tree, node, zero.length.tips.count = FALSE) {#
    if (length(node) == 1) {#
      if (!zero.length.tips.count | !is.tip(tree,node)) {#
        return(node)#
      } else {#
        length <- get.edge.length(tree, node)#
        while (length < 1E-5) {#
          node <- Ancestors(tree, node, type = "parent")#
          if (is.root(tree, node)) {#
            break#
          }#
          length <- get.edge.length(tree, node)#
        }#
        return(node)#
      }#
    } else {#
      mrca <- mrca.phylo(tree, node)#
      return(mrca)#
    }#
  }#
#
# This function returns TRUE wherever elements are the same, including NA's, and false #
# everywhere else.#
#
#' @keywords internal#
#' @export compareNA#
#
compareNA <- function(v1,v2) {#
  same <- (v1 == v2)  |  (is.na(v1) & is.na(v2))#
  same[is.na(same)] <- FALSE#
  return(same)#
}#
#
# Last element in a vector#
#
#' @keywords internal#
#' @export get.last#
#
get.last <- function(vec)#
  return(vec[length(vec)])#
#
# Get host id from tip label#
#
#' @keywords internal#
#' @export host.from.label#
#
host.from.label <- function(label, regexp){#
  if(length(grep(regexp, label)>0)) {#
    return(sub(regexp, "\\1", label))#
  } else {#
    return(NA)#
  }#
}#
#
# Get read count from label#
#
#' @keywords internal#
#' @export read.count.from.label#
#
read.count.from.label <- function(label, regexp){#
  if(length(grep(regexp, label)>0)) {#
    return(as.integer(sub(regexp, "\\3", label)))#
  } else {#
    return(NA)#
  }#
}#
#
# Starting at node 1, determine whether the path to node 2 is blocked by node 3#
# Should work on both rooted and unrooted trees I _hope_.#
#
#' @keywords internal#
#' @export path.exists#
#
path.exists <- function(tree, node.1, node.2, node.3, last.node = -1){#
  #  cat(node.1," ")#
  if(node.1 == node.2){#
    return(TRUE)#
  }#
  if(node.1 == node.3){#
    return(FALSE)#
  }#
  neighbours = vector()#
  if(!is.tip(tree, node.1)){#
    neighbours <- Children(tree, node.1)#
  }#
  if(length(Ancestors(tree, node.1, type="parent"))!=0){#
    if(Ancestors(tree, node.1, type="parent")!=0){#
      neighbours <- c(neighbours, Ancestors(tree, node.1, type="parent"))#
    }#
  }#
  for(neighbour in neighbours){#
    if(neighbour != last.node){#
      if(path.exists(tree, neighbour, node.2, node.3, node.1)){#
        return(TRUE)#
        break#
      }#
    }#
  }#
  #you've been everywhere and you can't find a way through#
  return(FALSE)#
}#
#
#' @keywords internal#
#' @export tips.reachable#
#
tips.reachable <- function(tree, node, blocking.edges, last.node = -1){#
  out <- vector()#
  if(is.tip(tree, node)){#
    out <- c(out, node)#
  }#
  neighbours = neighbouring.nodes(tree, node)#
  for(neighbour in neighbours){#
    if(neighbour != last.node){#
      edge.vec <- c(node, neighbour)#
      if(is.na(row.match(edge.vec, t(as.matrix(blocking.edges)))) &  is.na(row.match(rev(edge.vec), t(as.matrix(blocking.edges))))){#
        out <- c(out, tips.reachable(tree, neighbour, blocking.edges, node))#
      }#
    }#
  }#
  return(out)#
}#
#
#' @keywords internal#
#' @export neighbouring.nodes#
#
neighbouring.nodes <- function(tree, node){#
  part.1 <- tree$edge[which(tree$edge[,2]==node), 1]#
  part.2 <- tree$edge[which(tree$edge[,1]==node), 2]#
  return(c(part.1, part.2))#
}#
# Drop a set of tips and return a vector which maps nodes from the full tree to the subtree#
#
#' @keywords internal#
#' @export drop.tip.get.map#
#
drop.tip.get.map <- function(phy, tip){#
  if(length(unique(tree$tip.label))!=length(tree$tip.label)){#
    stop("This won't work if there are duplicate tip names")#
  }#
  reference <- vector()#
  phy.2 <- drop.tip(phy, tip)#
  for(new.label in seq(1, length(phy.2$tip.label))){#
    reference[new.label] = which(phy$tip.label==phy.2$tip.label[new.label])#
  }#
  mrcas.1 <- mrca(phy)#
  mrcas.2 <- mrca(phy.2)#
  for(tip.1 in seq(1, length(phy.2$tip.label))){#
    for(tip.2 in seq(1, length(phy.2$tip.label))){#
      if(tip.1 < tip.2){#
        new.mrca <- mrcas.2[tip.1,tip.2]#
        old.mrca <- mrcas.1[reference[tip.1], reference[tip.2]]#
        reference[new.mrca] = old.mrca#
      }#
    }#
  }#
  return(list(tree = phy.2, reference=reference))#
}#
#
#' @keywords internal#
#' @export extract.subtrees.for.hosts#
#
extract.subtrees.for.hosts <- function(tree, hosts, splits){#
  labels.to.keep <- splits$tip.names[which(splits$orig.hosts %in% hosts)]#
  pruned.tree <- drop.tip(tree, which(!(tree$tip.label %in% labels.to.keep)))#
  return(pruned.tree)#
}#
#
#' @keywords internal#
#' @export prop.internal.longer.than.root#
#
prop.internal.longer.than.root <- function(tree, split, splits){#
  tips <- splits$tip.names[which(splits$host.splits==split)]#
  if(length(tips)==1){#
    return(0)#
  }#
  split.root <- mrca.phylo.or.unique.tip(tree, which(tree$tip.label %in% tips))#
  dist.to.root <- 0 #
  current.node <- split.root#
  while(!is.root(tree, current.node)){#
    dist.to.root <- dist.to.root + get.edge.length(tree, split.root)#
    current.node <- Ancestors(tree, current.node, type="parent")#
  }#
  just.clade <- drop.tip(tree, which(!(tree$tip.label %in% tips)))#
  edges <- just.clade$edge.length#
  return(sum(edges > dist.to.root)/length(edges))#
}#
#
#' @keywords internal#
#' @export process.tree#
#' @importFrom ape di2multi root#
#
process.tree <- function(tree, root.name=NULL, m.thresh=-1, blacklist.for.pruning = vector(), normalisation.constant = 1) {#
  if(m.thresh != -1){#
    tree <- di2multi(tree, tol = m.thresh)#
  }#
  if(!is.null(root.name)){#
    tree <- root(tree, outgroup = root.name, resolve.root = T)#
  } else {#
    # There are problems with a non-binary root.  Resolve it arbitrarily; most times a root should be specified.#
    if(length(Children(tree, getRoot(tree)))>2){#
      first.child <- Children(tree, getRoot(tree))[1]#
      if(first.child <= length(tree$tip.label)){#
        tree <- root(tree, outgroup=first.child, resolve.root = T)#
      } else {#
        tree <- root(tree, node=first.child, resolve.root = T)#
      }#
    }#
  }#
  if(length(blacklist.for.pruning) > 0){#
    tree <- drop.tip(tree, blacklist.for.pruning)#
  }#
  tree$edge.length <- tree$edge.length/normalisation.constant#
  return(tree)#
}#
#
#' @title Select for further analysis relationship classifications by read and tip counts #
#' @export select.windows.by.read.and.tip.count#
#' @import tidyverse #
#' @author Oliver Ratmann, Matthew Hall#
#' @param ptrees A list of class \code{phyloscanner.trees} produced by \code{phyloscanner.analyse.trees}.#
#' @param dwin A data frame produced by \code{classify.pairwise.relationships}.#
#' @param tip.regex The regular expression used to identify host IDs in tip names#
#' @param min.reads The minimum number of reads from a host in a window needed in order for that window to count in determining relationships involving that patient#
#' @param min.tips The minimum number of tips from a host in a window needed in order for that window to count in determining relationships involving that patient#
#' @param verbose Verbose output#
#' @return A data frame with viral phylogenetic classifications of pairwise host relationships in each deep sequence phylogeny#
#' @examples#
#' \dontrun{#
#' require(phyloscannerR)#
#' ##
#' #	continue Rakai example,#
#' #	load phyloscanner output from 'phyloscanner.analyse.trees'#
#' #	#
#' file	<- system.file(file.path('extdata','ptyr192_phsc_analyse_trees_output.R'),package='phyloscannerR')#
#' load(file)	#loads 'phsc', output from 'phyloscanner.analyse.trees'#
#' #	use distance thresholds found in analysis of Rakai couples#
#' close.threshold <- 0.025#
#' distant.threshold <- 0.05	#
#' #	use relationship types based on adjacency#
#' #	this also considers linkage etc between individuals who have dual infections, recombinants etc #
#' #	..and thus may not have *all* their subgraphs adjacent to each other#
#' relationship.types <- c('proximity.3.way',					#
#' 		'close.and.adjacent',					#
#' 		'close.and.adjacent.and.directed',					#
#' 		'close.and.adjacent.and.ancestry.cat')	#
#' dwin <- classify.pairwise.relationships(phsc, allow.mt=TRUE, close.threshold=close.threshold, distant.threshold=distant.threshold,relationship.types=relationship.types, verbose=TRUE)#
#' tip.regex <- "^(.*)_fq[0-9]+_read_([0-9]+)_count_([0-9]+)$"#
#' min.reads <- 30#
#' min.tips <- 1#
#' dwin <- select.windows.by.read.and.tip.count(phsc, dwin, tip.regex, min.reads, min.tips)#
#' ##
#' # 	end of Rakai example#
#' ##
#' }	 	#
select.windows.by.read.and.tip.count <- function(ptrees, dwin, tip.regex, min.reads, min.tips, verbose=F)			#
{#
  host.tips.and.reads <- map(ptrees, function(x) phyloscannerR:::get.tip.and.read.counts(x, all.hosts.from.trees(ptrees), tip.regex, attr(ptrees, 'has.read.counts'), verbose = F))#
  host.tips.and.reads <- bind_rows(host.tips.and.reads)#
  if(verbose) cat('Merging tip and read counts...\n')#
  dwin <- dwin %>% #
    inner_join(host.tips.and.reads, by=c("host.1"="host.id", "tree.id")) %>% #
    rename(tips.1 = tips, reads.1=reads)#
  dwin <- dwin %>% #
    inner_join(host.tips.and.reads, by=c("host.2"="host.id", "tree.id")) %>% #
    rename(tips.2 = tips, reads.2=reads)	#
  if(verbose) cat('Reducing transmission window stats to windows with at least',min.reads,'reads and at least',min.tips,'tips...\n')#
  dwin	<- dwin %>% #
    filter(reads.1 >= min.reads & reads.2 >= min.reads & tips.1 >= min.tips & tips.2 >= min.tips)#
  if(verbose) cat('Total number of windows with transmission assignments is ',nrow(dwin),'.\n', sep="")		#
  dwin#
}#
#
#' @title Cast phyloscanner tree to SIMMAP tree#
#' @export phyloscanner.to.simmap#
#' @author Oliver Ratmann#
#' @importFrom reshape2 dcast#
#' @usage phyloscanner.to.simmap(ph, delete.phyloscanner.structures)#
#' @param ph A \code{phyloscanner.tree} with attributes \code{SPLIT}, \code{INDIVIDUAL}, \code{BRANCH_COLOURS}, \code{SUBGRAPH_MRCA}.#
#' @param delete.phyloscanner.structures Logical value. If true \code{phyloscanner} attributes are removed from the tree.#
#' @return Same tree in \code{SIMMAP} format, with elements \code{maps}, \code{mapped.edge}, \code{node.states}.#
#' @seealso \code{\link{simmap.to.phyloscanner}}, \code{\link{extract.subgraph}}#
#' @example inst/example/ex.cast.to.simmap.R#
phyloscanner.to.simmap<- function(ph, delete.phyloscanner.structures=FALSE)#
{#
	# make maps for each edge#
	# attr(ph, 'SPLIT') specifies state of branch ending in node #
	edge.state <- as.character( attr(ph, 'SPLIT')[ ph$edge[,2] ] )#
	edge.state[is.na(edge.state)] <- 'Unknown'	#
	edge.maps <- ph$edge.length	#
	# make mapped.edge matrix#
	mapped.edge <- data.frame(STATE= edge.state, LEN=edge.maps, IDX=seq_along(edge.state))#
	mapped.edge <- reshape2:::dcast(mapped.edge, IDX~STATE, value.var='LEN')#
	for(x in colnames(mapped.edge))#
		mapped.edge[[x]][ which(is.na(mapped.edge[[x]])) ] <- 0#
	mapped.edge <- as.matrix(mapped.edge)	#
	rownames(mapped.edge) <- apply(ph$edge,1,paste, collapse=',')	#
	# finalise edge.maps#
	edge.maps <- lapply(seq_along(edge.maps), function(k){ x<- edge.maps[[k]]; names(x)<- edge.state[k]; x})#
	# make node.states	#
	node.states <- as.character( attr(ph, 'SPLIT')[ ph$edge[,1] ] )#
	node.states[is.na(node.states)] <- 'Unknown'#
	node.states <- matrix(node.states, nrow=nrow(ph$edge), ncol=2)	#
	node.states[,2] <- edge.state#
	# set list elements#
	ph[['maps']] <- edge.maps#
	ph[['mapped.edge']] <- mapped.edge#
	ph[['node.states']] <- node.states#
	# set attributes#
	attr(ph,'class') <- c("simmap", "phylo")#
	attr(ph, "map.order") <- "right-to-left"#
	attr(ph, "order") <- "cladewise"#
	# delete attributes#
	if(delete.phyloscanner.structures)#
	{#
		attr(ph, "SPLIT") <- NULL#
		attr(ph, "INDIVIDUAL") <- NULL#
		attr(ph, "BRANCH_COLOURS") <- NULL#
		attr(ph, "SUBGRAPH_MRCA") <- NULL	#
	}	#
	ph#
}#
#
#' @title Cast SIMMAP tree to phyloscanner tree#
#' @export simmap.to.phyloscanner#
#' @importFrom phangorn Ancestors#
#' @author Oliver Ratmann#
#' @usage simmap.to.phyloscanner(ph, delete.simmap.structures)#
#' @param ph A \code{SIMMAP} tree with elements \code{maps}, \code{mapped.edge}, \code{node.states}.#
#' @param delete.simmap.structures Logical value. If true \code{SIMMAP} elements are removed from the tree.#
#' @return Same tree in \code{phyloscanner.tree} format, with attributes \code{SPLIT}, \code{INDIVIDUAL}, \code{BRANCH_COLOURS}, \code{SUBGRAPH_MRCA}.#
#' @seealso \code{\link{phyloscanner.to.simmap}}, \code{\link{extract.subgraph}}#
#' @example inst/example/ex.cast.to.simmap.R#
simmap.to.phyloscanner <- function(ph, delete.simmap.structures=FALSE)#
{#
	stopifnot( any(class(ph)=='simmap') )#
	# state at each node. set root to Unknown by default#
	node.states <- vector('character', Nnode(ph, internal.only=FALSE))#
	node.states[ph$edge[,2]] <- ph$node.states[,2]#
	node.states[Ntip(ph)+1] <- 'Unknown'#
	# find subgraph mrcas#
	subgraphs <- setdiff(sort(unique(node.states)),'Unknown') #
	# for each subgraph, find one member node#
	subgraph.member <- sapply(subgraphs, function(x) which(node.states==x)[1] )#
	# for each member, descend in tree and find most ancestral member node, which is the mrca of the subgraph#
	subgraph.ancestors <- phangorn:::Ancestors(ph, subgraph.member)#
	subgraph.mrcas <- sapply(seq_along(subgraph.ancestors), function(j){				#
				subgraph.mrca <- subgraph.member[j]#
				subgraph.name <- names(subgraph.member)[j]#
				nodes.in.same.subgraph.idx <- which(node.states[subgraph.ancestors[[j]]]==subgraph.name)#
				if(length(nodes.in.same.subgraph.idx))#
					subgraph.mrca <- subgraph.ancestors[[j]][ tail(nodes.in.same.subgraph.idx,1) ]#
				subgraph.mrca#
			})#
	names(subgraph.mrcas) <- subgraphs#
	#	make phyloscanner attributes#
	attr(ph, 'SPLIT') <- node.states#
	tmp <- rep(FALSE, length(node.states))#
	tmp[subgraph.mrcas] <- TRUE#
	attr(ph, 'SUBGRAPH_MRCA') <- tmp#
	attr(ph, 'INDIVIDUAL') <- gsub('-SPLIT[0-9]+','',node.states)#
	tmp <- t( rbind( node.states[ ph$edge[,1] ], #
					node.states[ ph$edge[,2] ], #
					node.states[ ph$edge[,2] ] ) )#
	tmp[tmp[,1]!=tmp[,2], 3] <- 'Unknown'	#
	tmp <- gsub('-SPLIT[0-9]+','',tmp[,3])#
	attr(ph, 'BRANCH_COLOURS') <- rep(NA, Nnode(ph, internal.only=FALSE)) #
	attr(ph, 'BRANCH_COLOURS')[ ph$edge[,2] ] <- tmp		#
	attr(ph, 'SPLIT')[attr(ph, 'SPLIT')=='Unknown'] <- NA#
	attr(ph, 'INDIVIDUAL')[attr(ph, 'INDIVIDUAL')=='Unknown'] <- NA#
	attr(ph, 'BRANCH_COLOURS')[attr(ph, 'BRANCH_COLOURS')=='Unknown'] <- NA#
	attr(ph, 'SPLIT') <- factor(attr(ph, 'SPLIT'))#
	attr(ph, 'INDIVIDUAL') <- factor(attr(ph, 'INDIVIDUAL'))#
	attr(ph, 'BRANCH_COLOURS') <- factor(attr(ph, 'BRANCH_COLOURS'))#
	if(delete.simmap.structures)#
	{#
		ph[["maps"]] <- NULL#
		ph[["mapped.edge"]] <- NULL#
		ph[["node.states"]] <- NULL#
		attr(ph, 'map.order') <- NULL#
		attr(ph, 'class') <- 'phylo'		#
	}#
	ph#
}#
#
#' @title Extract subgraph from phyloscanner tree#
#' @export extract.subgraph#
#' @importFrom phangorn Ancestors#
#' @author Oliver Ratmann#
#' @usage extract.subgraph(ph, mrca)#
#' @param ph A tree of class \code{SIMMAP} and \code{phyloscanner}, i.e. with elements \code{maps}, \code{mapped.edge}, \code{node.states} and with attributes \code{SPLIT}, \code{INDIVIDUAL}, \code{BRANCH_COLOURS}, \code{SUBGRAPH_MRCA}.#
#' @param mrca Node index of subgraph MRCA#
#' @return Subgraph in ape format, with additional elements \code{subgraph.name} (subgraph name in the phyloscanner SPLIT attribute), \code{subgraph.root.edge} (length of the ancestral edge of the subgraph MRCA), \code{subgraph.parent.state} (ancestral state of the parent of subgraph MRCA).  #
#' @seealso \code{\link{phyloscanner.to.simmap}}#
#' @example inst/example/ex.extract.subgraph.R#
extract.subgraph<- function(ph, mrca)#
{#
	stopifnot( any(class(ph)=='simmap') )#
	stopifnot( c("SPLIT","INDIVIDUAL","BRANCH_COLOURS","SUBGRAPH_MRCA")%in%names(attributes(ph)) )#
	subgraph.name <- as.character(attr(ph, 'SPLIT')[mrca])#
	host <- as.character(attr(ph, "INDIVIDUAL")[mrca])#
	subgraph.root.edge <- ph$edge.length[ which( ph$edge[,2]==mrca ) ]#
	subgraph.parent.state <- as.character(attr(ph, "BRANCH_COLOURS")[ ph$edge[ph$edge[,2]==mrca,1] ])#
	stopifnot( is.na(subgraph.parent.state) || subgraph.parent.state!=host )#
	if(mrca<=Ntip(ph))#
	{#
		subgraph<- list(	edge= matrix(nrow=0, ncol=2), #
				edge.length=vector('numeric',0),#
				Nnode=0,#
				tip.label=ph$tip.label[mrca],#
				maps= vector('list',0),#
				mapped.edge= matrix(nrow=0, ncol=0),#
				node.states= matrix(nrow=0, ncol=2)#
		)#
		#attr(subgraph,'class') <- c( "phylo")#
		#attr(subgraph, "map.order") <- "right-to-left"#
		#attr(subgraph, "order") <- "cladewise"		#
	}#
	if(mrca>Ntip(ph))#
	{#
		subgraph <- phytools:::extract.clade.simmap(ph, mrca)#
		subgraph.root <- Ntip(subgraph)+1L#
		descendants <- Descendants(subgraph, subgraph.root, type='all')#
		tmp <- sapply(descendants, function(x) which(subgraph$edge[,2]==x))#
		descendants.states <- subgraph[['node.states']][tmp,2]#
		descendants.not.in.subgraph <- descendants[ descendants.states!=subgraph.name ]#
		if(length(descendants.not.in.subgraph))#
		{#
			# find all tips of descendants.not.in.subgraph, and remove the corresponding tips, which will remove the subtree for each descendant#
			tips.not.in.subgraph <- sort(unique(unlist(Descendants(subgraph, descendants.not.in.subgraph, type='tips'))))#
			subgraph <- ape:::drop.tip(subgraph, tips.not.in.subgraph)#
			subgraph[['maps']] <- NULL#
			subgraph[['mapped.edge']] <- NULL#
			subgraph[['node.states']] <- NULL#
			attr(subgraph,'class') <- c( "phylo")#
			attr(subgraph, "map.order") <- NULL#
			attr(subgraph, "order") <- NULL#
			attr(subgraph, "SPLIT") <- NULL#
			attr(subgraph, "INDIVIDUAL") <- NULL#
			attr(subgraph, "BRANCH_COLOURS") <- NULL#
			attr(subgraph, "SUBGRAPH_MRCA") <- NULL			#
		}		#
	}#
	subgraph[['subgraph.name']]<- subgraph.name#
	subgraph[['subgraph.root.edge']]<- subgraph.root.edge#
	subgraph[['subgraph.parent.state']]<- subgraph.parent.state#
	subgraph	#
}
phyloscanner.to.simmap(ph)
ph <- phyloscanner.to.simmap(ph)	#
		ph <- phytools:::drop.tip.simmap(ph, ph$tip.label[tmp])#
		ph <- simmap.to.phyloscanner(ph)
dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		dph <- merge(dph, dph.old, by= 'TAXA')#
		stopifnot( !any(is.na(dph$SEQ_DATE)) )#
		dph <- dph[order(TAXA_ID),]#
		#	get into format needed for tree.dater	#
		#sampling.times <- dph$SEQ_DATE#
		#names(sampling.times) <- dph$TAXA_LABEL	#
		sampling.times.init <- dph$SEQ_DATE#
		names(sampling.times.init) <- dph$TAXA_LABEL#
		sampling.times.bounds <- as.data.frame(subset(dph, select=c(SEQ_DATE_LOWER, SEQ_DATE_UPPER)))#
		rownames(sampling.times.bounds) <- dph$TAXA_LABEL		#
		colnames(sampling.times.bounds) <- c('lower','upper')
ph.dated <- dater(ph, sampling.times.init, alignment.length, numStartConditions=1, estimateSampleTimes=sampling.times.bounds )#
		stopifnot( all(  ph.dated$tip.label == ph$tip.label ) )#
		stopifnot( all( ph.dated$edge == ph$edge ) )
ph$edge.length <- ph.dated$edge.length#
		##
		#	plot dated tree to spot obvious errors#
		##
		outfile <- gsub('workspace\\.rda','annotated_dated_tree.pdf',infile)#
		tmp <- vector('list')#
		tmp[['tree']] <- ph#
		tmp[['tree']][['node.states']] <- tmp[['tree']][['mapped.edge']] <- tmp[['tree']][['maps']] <- NULL#
		attr(tmp[['tree']],'map.order') <- NULL#
		attr(tmp[['tree']],'class') <- 'phylo'#
		tmp[['read.counts']] <- rep(1, Ntip(ph))	#
		write.annotated.tree(tmp, outfile, format="pdf", pdf.scale.bar.width = 0.01, pdf.w = 40, pdf.hm = 0.2, verbose = FALSE)#
		##
		#	save phyloscanner.tree#
		##
		outfile <- gsub('workspace\\.rda','annotated_dated_tree.rda',infile)#
		save(ph, file=outfile)
require(phyloscannerR)
i<- 1
infile <- infiles.phsc[i,F]	#
		load(infile)#
		ph <- phyloscanner.trees[[1]][['tree']]#
		stopifnot( !any( ph$tip.label=='' ) )#
		##
		#	drop tips without sequence dates, #
		#	while conserving the ancestral state reconstructions#
		##
		#	extract taxa names#
		dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		#	add Seattle sequence dates#
		dph <- merge(dph, dseq, by='TAXA', all.x=TRUE)#
		#	extract GenBank sequence dates from taxa names where possible #
		dph[, GENBANK_ID:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\5',TAXA)]#
		dph[, GENBANK_SEQDATE:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\3',TAXA)]#
		set(dph, dph[, which(GENBANK_SEQDATE=='-' | !is.na(SEQ_DATE))],'GENBANK_SEQDATE',NA_character_)	#
		set(dph, NULL, 'GENBANK_SEQDATE_LOWER', dph[, as.numeric(GENBANK_SEQDATE) ])#
		set(dph, NULL, 'GENBANK_SEQDATE_UPPER', dph[, as.numeric(GENBANK_SEQDATE) + 364/365 ])	#
		set(dph, NULL, 'GENBANK_SEQDATE', dph[, as.numeric(GENBANK_SEQDATE) + 1/2 ])#
		tmp <- dph[, which(is.na(SEQ_DATE))]#
		set(dph, tmp, 'SEQ_DATE', dph[tmp, GENBANK_SEQDATE])#
		set(dph, tmp, 'SEQ_DATE_LOWER', dph[tmp, GENBANK_SEQDATE_LOWER])#
		set(dph, tmp, 'SEQ_DATE_UPPER', dph[tmp, GENBANK_SEQDATE_UPPER])#
		set(dph, NULL, c('GENBANK_SEQDATE','GENBANK_SEQDATE_LOWER','GENBANK_SEQDATE_UPPER'), NULL)	#
		#	drop tips #
		dph.old <- subset(dph, select=c(TAXA, SEQ_DATE, SEQ_DATE_LOWER, SEQ_DATE_UPPER))	#
		tmp <- subset(dph, is.na(SEQ_DATE))[, TAXA_ID]#
		cat('Dropping tips without sampling date from ', infile,' n=', length(tmp), 'of Ntips=', Ntip(ph), '\n')#
		ph <- phyloscanner.to.simmap(ph)	#
		ph <- phytools:::drop.tip.simmap(ph, ph$tip.label[tmp])#
		ph <- simmap.to.phyloscanner(ph)#
		##
		#	date tree#
		#	#
		#	make data.table of sequence sampling times#
		dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		dph <- merge(dph, dph.old, by= 'TAXA')#
		stopifnot( !any(is.na(dph$SEQ_DATE)) )#
		dph <- dph[order(TAXA_ID),]#
		#	get into format needed for tree.dater	#
		#sampling.times <- dph$SEQ_DATE#
		#names(sampling.times) <- dph$TAXA_LABEL	#
		sampling.times.init <- dph$SEQ_DATE#
		names(sampling.times.init) <- dph$TAXA_LABEL#
		sampling.times.bounds <- as.data.frame(subset(dph, select=c(SEQ_DATE_LOWER, SEQ_DATE_UPPER)))#
		rownames(sampling.times.bounds) <- dph$TAXA_LABEL		#
		colnames(sampling.times.bounds) <- c('lower','upper')#
		#	date tree#
		#ph.dated <- dater(ph, sampling.times, alignment.length, numStartConditions=1)#
		ph.dated <- dater(ph, sampling.times.init, alignment.length, numStartConditions=1, estimateSampleTimes=sampling.times.bounds )#
		stopifnot( all(  ph.dated$tip.label == ph$tip.label ) )#
		stopifnot( all( ph.dated$edge == ph$edge ) )#
		#	since the tree topology is unchanged, we can copy#
		#	the branch lenghts in units of time onto the original tree#
		#	that has the ancestral state reconstructions#
		ph$edge.length <- ph.dated$edge.length
outfile <- gsub('workspace\\.rda','annotated_dated_tree.pdf',infile)#
		tmp <- vector('list')#
		tmp[['tree']] <- ph#
		tmp[['tree']][['node.states']] <- tmp[['tree']][['mapped.edge']] <- tmp[['tree']][['maps']] <- NULL#
		attr(tmp[['tree']],'map.order') <- NULL#
		attr(tmp[['tree']],'class') <- 'phylo'#
		tmp[['read.counts']] <- rep(1, Ntip(ph))	#
		write.annotated.tree(tmp, outfile, format="pdf", pdf.scale.bar.width = 0.01, pdf.w = 40, pdf.hm = 0.2, verbose = FALSE)#
		##
		#	save phyloscanner.tree#
		##
		outfile <- gsub('workspace\\.rda','annotated_dated_tree.rda',infile)#
		save(ph, file=outfile)
for(i in seq_len(nrow(infiles.phsc)))#
	{#
		infile <- infiles.phsc[i,F]	#
		load(infile)#
		ph <- phyloscanner.trees[[1]][['tree']]#
		stopifnot( !any( ph$tip.label=='' ) )#
		##
		#	drop tips without sequence dates, #
		#	while conserving the ancestral state reconstructions#
		##
		#	extract taxa names#
		dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		#	add Seattle sequence dates#
		dph <- merge(dph, dseq, by='TAXA', all.x=TRUE)#
		#	extract GenBank sequence dates from taxa names where possible #
		dph[, GENBANK_ID:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\5',TAXA)]#
		dph[, GENBANK_SEQDATE:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\3',TAXA)]#
		set(dph, dph[, which(GENBANK_SEQDATE=='-' | !is.na(SEQ_DATE))],'GENBANK_SEQDATE',NA_character_)	#
		set(dph, NULL, 'GENBANK_SEQDATE_LOWER', dph[, as.numeric(GENBANK_SEQDATE) ])#
		set(dph, NULL, 'GENBANK_SEQDATE_UPPER', dph[, as.numeric(GENBANK_SEQDATE) + 364/365 ])	#
		set(dph, NULL, 'GENBANK_SEQDATE', dph[, as.numeric(GENBANK_SEQDATE) + 1/2 ])#
		tmp <- dph[, which(is.na(SEQ_DATE))]#
		set(dph, tmp, 'SEQ_DATE', dph[tmp, GENBANK_SEQDATE])#
		set(dph, tmp, 'SEQ_DATE_LOWER', dph[tmp, GENBANK_SEQDATE_LOWER])#
		set(dph, tmp, 'SEQ_DATE_UPPER', dph[tmp, GENBANK_SEQDATE_UPPER])#
		set(dph, NULL, c('GENBANK_SEQDATE','GENBANK_SEQDATE_LOWER','GENBANK_SEQDATE_UPPER'), NULL)	#
		#	drop tips #
		dph.old <- subset(dph, select=c(TAXA, SEQ_DATE, SEQ_DATE_LOWER, SEQ_DATE_UPPER))	#
		tmp <- subset(dph, is.na(SEQ_DATE))[, TAXA_ID]#
		cat('Dropping tips without sampling date from ', infile,' n=', length(tmp), 'of Ntips=', Ntip(ph), '\n')#
		ph <- phyloscanner.to.simmap(ph)	#
		ph <- phytools:::drop.tip.simmap(ph, ph$tip.label[tmp])#
		ph <- simmap.to.phyloscanner(ph)#
		##
		#	date tree#
		#	#
		#	make data.table of sequence sampling times#
		dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		dph <- merge(dph, dph.old, by= 'TAXA')#
		stopifnot( !any(is.na(dph$SEQ_DATE)) )#
		dph <- dph[order(TAXA_ID),]#
		#	get into format needed for tree.dater	#
		#sampling.times <- dph$SEQ_DATE#
		#names(sampling.times) <- dph$TAXA_LABEL	#
		sampling.times.init <- dph$SEQ_DATE#
		names(sampling.times.init) <- dph$TAXA_LABEL#
		sampling.times.bounds <- as.data.frame(subset(dph, select=c(SEQ_DATE_LOWER, SEQ_DATE_UPPER)))#
		rownames(sampling.times.bounds) <- dph$TAXA_LABEL		#
		colnames(sampling.times.bounds) <- c('lower','upper')#
		#	date tree#
		#ph.dated <- dater(ph, sampling.times, alignment.length, numStartConditions=1)#
		ph.dated <- dater(ph, sampling.times.init, alignment.length, numStartConditions=1, estimateSampleTimes=sampling.times.bounds )#
		stopifnot( all(  ph.dated$tip.label == ph$tip.label ) )#
		stopifnot( all( ph.dated$edge == ph$edge ) )#
		#	since the tree topology is unchanged, we can copy#
		#	the branch lenghts in units of time onto the original tree#
		#	that has the ancestral state reconstructions#
		ph$edge.length <- ph.dated$edge.length#
		##
		#	plot dated tree to spot obvious errors#
		##
		outfile <- gsub('workspace\\.rda','annotated_dated_tree.pdf',infile)#
		tmp <- vector('list')#
		tmp[['tree']] <- ph#
		tmp[['tree']][['node.states']] <- tmp[['tree']][['mapped.edge']] <- tmp[['tree']][['maps']] <- NULL#
		attr(tmp[['tree']],'map.order') <- NULL#
		attr(tmp[['tree']],'class') <- 'phylo'#
		tmp[['read.counts']] <- rep(1, Ntip(ph))	#
		write.annotated.tree(tmp, outfile, format="pdf", pdf.scale.bar.width = 0.01, pdf.w = 40, pdf.hm = 0.2, verbose = FALSE)#
		##
		#	save phyloscanner.tree#
		##
		outfile <- gsub('workspace\\.rda','annotated_dated_tree.rda',infile)#
		save(ph, file=outfile)#
	}
require(data.table)#
	require(phangorn)#
	require(ggplot2)#
	require(reshape)#
	require(phyloscannerR)#
	#	working directory with phyloscanner output#
	home <- '/Users/Oliver/Box Sync/OR_Work/Seattle'#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	infiles		<- data.table(F=list.files(indir.phsc, pattern='_annotated_dated_tree.rda$', full.names=TRUE, recursive=TRUE))
infiles
infiles[, SELECT:= gsub('^.*_rerooted_([A-Za-z0-9]+)_.*$','',basename(F))]
infiles
infiles[, SELECT:= gsub('^.*_rerooted_([A-Za-z0-9]+)_.*$','\\1',basename(F))]
infiles
i<- 1#
		cat('process', i,'\n')#
		infile <- infiles[i, F]#
		host <- infiles[i,SELECT]#
		load(infile)
mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]
extract.subgraph
mrcas
stopifnot( any(attr(ph,'class')=='simmap') )#
		# extract subgraphs#
		subgraphs <- lapply(mrcas, function(mrca) extract.subgraph(ph, mrca))
subgraphs
outfile <- gsub('_annotated_dated_tree',paste0('_datedsubgraphs_',host),infile)
outfile
for(i in seq_len(nrow(infiles)))#
	{#
		#i<- 1#
		cat('process', i,'\n')#
		infile <- infiles[i, F]#
		host <- infiles[i,SELECT]#
		load(infile)					#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]	#
		# check that tree is of class simmap#
		stopifnot( any(attr(ph,'class')=='simmap') )#
		# extract subgraphs#
		subgraphs <- lapply(mrcas, function(mrca) extract.subgraph(ph, mrca))#
		# save#
		outfile <- gsub('_annotated_dated_tree',paste0('_datedsubgraphs_',host),infile)#
		save(subgraphs, file=outfile)#
	}
extract.subgraph<- function(ph, mrca)#
{#
	stopifnot( any(class(ph)=='simmap') )#
	stopifnot( c("SPLIT","INDIVIDUAL","BRANCH_COLOURS","SUBGRAPH_MRCA")%in%names(attributes(ph)) )#
	subgraph.name <- as.character(attr(ph, 'SPLIT')[mrca])#
	host <- as.character(attr(ph, "INDIVIDUAL")[mrca])#
	subgraph.root.edge <- ph$edge.length[ which( ph$edge[,2]==mrca ) ]#
	subgraph.parent.state <- as.character(attr(ph, "BRANCH_COLOURS")[ ph$edge[ph$edge[,2]==mrca,1] ])#
	stopifnot( is.na(subgraph.parent.state) || subgraph.parent.state!=host )#
	if(mrca<=Ntip(ph))#
	{#
		subgraph<- list(	edge= matrix(nrow=0, ncol=2), #
				edge.length=vector('numeric',0),#
				Nnode=0,#
				tip.label=ph$tip.label[mrca],#
				maps= vector('list',0),#
				mapped.edge= matrix(nrow=0, ncol=0),#
				node.states= matrix(nrow=0, ncol=2)#
		)#
		#attr(subgraph,'class') <- c( "phylo")#
		#attr(subgraph, "map.order") <- "right-to-left"#
		#attr(subgraph, "order") <- "cladewise"		#
	}#
	if(mrca>Ntip(ph))#
	{#
		subgraph <- phytools:::extract.clade.simmap(ph, mrca)#
		subgraph.root <- Ntip(subgraph)+1L#
		descendants <- Descendants(subgraph, subgraph.root, type='all')#
		tmp <- sapply(descendants, function(x) which(subgraph$edge[,2]==x))#
		descendants.states <- subgraph[['node.states']][tmp,2]#
		descendants.not.in.subgraph <- descendants[ descendants.states!=subgraph.name ]#
		if(length(descendants.not.in.subgraph))#
		{#
			# find all tips of descendants.not.in.subgraph, and remove the corresponding tips, which will remove the subtree for each descendant#
			tips.not.in.subgraph <- sort(unique(unlist(Descendants(subgraph, descendants.not.in.subgraph, type='tips'))))#
			subgraph <- ape:::drop.tip(subgraph, tips.not.in.subgraph)#
			subgraph[['maps']] <- NULL#
			subgraph[['mapped.edge']] <- NULL#
			subgraph[['node.states']] <- NULL#
			attr(subgraph,'class') <- c( "phylo")#
			attr(subgraph, "map.order") <- NULL#
			attr(subgraph, "order") <- NULL#
			attr(subgraph, "SPLIT") <- NULL#
			attr(subgraph, "INDIVIDUAL") <- NULL#
			attr(subgraph, "BRANCH_COLOURS") <- NULL#
			attr(subgraph, "SUBGRAPH_MRCA") <- NULL			#
		}		#
	}#
	subgraph[['subgraph.name']]<- subgraph.name#
	subgraph[['subgraph.root.edge']]<- subgraph.root.edge#
	subgraph[['subgraph.parent.state']]<- subgraph.parent.state#
	subgraph	#
}
for(i in seq_len(nrow(infiles)))#
	{#
		#i<- 1#
		cat('process', i,'\n')#
		infile <- infiles[i, F]#
		host <- infiles[i,SELECT]#
		load(infile)					#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]	#
		# check that tree is of class simmap#
		stopifnot( any(attr(ph,'class')=='simmap') )#
		# extract subgraphs#
		subgraphs <- lapply(mrcas, function(mrca) extract.subgraph(ph, mrca))#
		# save#
		outfile <- gsub('_annotated_dated_tree',paste0('_datedsubgraphs_',host),infile)#
		save(subgraphs, file=outfile)#
	}
traceback()
i<- 4#
		cat('process', i,'\n')#
		infile <- infiles[i, F]#
		host <- infiles[i,SELECT]#
		load(infile)					#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]
mrcas
Ntip(ph)
stopifnot( any(attr(ph,'class')=='simmap') )
mrcas <- na.omit(mrcas)
mrcas
mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]	#
		#	TODO unexpected NA --> needs checking#
		mrcas <- unlist(na.omit(mrcas))
mrcas
mrcas <- as.integer(na.omit(mrcas))
mrcas
for(i in seq_len(nrow(infiles)))#
	{#
		#i<- 4#
		cat('process', i,'\n')#
		infile <- infiles[i, F]#
		host <- infiles[i,SELECT]#
		load(infile)					#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]	#
		#	TODO unexpected NA --> needs checking#
		if(any(is.na(mrcas)))#
			cat('\nFound unexpected NA in mrcas',basename(infile))#
		mrcas <- as.integer(na.omit(mrcas))#
		# check that tree is of class simmap#
		stopifnot( any(attr(ph,'class')=='simmap') )#
		# extract subgraphs#
		subgraphs <- lapply(mrcas, function(mrca) extract.subgraph(ph, mrca))#
		# save#
		outfile <- gsub('_annotated_dated_tree',paste0('_datedsubgraphs_',host),infile)#
		save(subgraphs, file=outfile)#
	}
infiles
subset(infiles, basename(F)!='180709_LANL_SubtypeBc13_mafft_ndrm_000_ft_rerooted_KCMSM__annotated_dated_tree.rda')
infiles <- subset(infiles, basename(F)!='180709_LANL_SubtypeBc13_mafft_ndrm_000_ft_rerooted_KCMSM__annotated_dated_tree.rda')#
	#	extract subgraphs of dated trees#
	for(i in seq_len(nrow(infiles)))#
	{#
		#i<- 4#
		cat('process', i,'\n')#
		infile <- infiles[i, F]#
		host <- infiles[i,SELECT]#
		load(infile)					#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]	#
		#	TODO unexpected NA --> needs checking#
		if(any(is.na(mrcas)))#
			cat('\nFound unexpected NA in mrcas',basename(infile))#
		mrcas <- as.integer(na.omit(mrcas))#
		# check that tree is of class simmap#
		stopifnot( any(attr(ph,'class')=='simmap') )#
		# extract subgraphs#
		subgraphs <- lapply(mrcas, function(mrca) extract.subgraph(ph, mrca))#
		# save#
		outfile <- gsub('_annotated_dated_tree',paste0('_datedsubgraphs_',host),infile)#
		save(subgraphs, file=outfile)#
	}
home <- '/Users/Oliver/Box Sync/OR_Work/Seattle'#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	infiles		<- data.table(F=list.files(indir.phsc, pattern='_annotated_dated_tree.rda$', full.names=TRUE, recursive=TRUE))	#
	infiles[, SELECT:= gsub('^.*_rerooted_([A-Za-z0-9]+)_.*$','\\1',basename(F))]#
	infiles <- subset(infiles, basename(F)!='180709_LANL_SubtypeBc13_mafft_ndrm_000_ft_rerooted_KCMSM__annotated_dated_tree.rda')#
	infiles <- subset(infiles, basename(F)!='180709_LANL_SubtypeBc9_mafft_ndrm_000_ft_rerooted_KC__annotated_dated_tree.rda')#
	#	extract subgraphs of dated trees#
	for(i in seq_len(nrow(infiles)))#
	{#
		#i<- 4#
		cat('process', i,'\n')#
		infile <- infiles[i, F]#
		host <- infiles[i,SELECT]#
		load(infile)					#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]	#
		#	TODO unexpected NA --> needs checking#
		if(any(is.na(mrcas)))#
			cat('\nFound unexpected NA in mrcas',basename(infile))#
		mrcas <- as.integer(na.omit(mrcas))#
		# check that tree is of class simmap#
		stopifnot( any(attr(ph,'class')=='simmap') )#
		# extract subgraphs#
		subgraphs <- lapply(mrcas, function(mrca) extract.subgraph(ph, mrca))#
		# save#
		outfile <- gsub('_annotated_dated_tree',paste0('_datedsubgraphs_',host),infile)#
		save(subgraphs, file=outfile)#
	}
~/Box Sync/OR_Work/Seattle/analysis_191017/phyloscanner
home <- '~/Box Sync/OR_Work/Seattle/phyloscanner_out_190723/KCHSX'#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	outdir <- '~/Box Sync/OR_Work/Seattle/analysis_190723/KCHSX'#
	##
	#	extract subgraph taxa	#
	##
	infiles		<- data.table(F=list.files(indir.phsc, pattern='rda$', full.names=TRUE, recursive=TRUE))#
	subset(infiles, grepl('datedsubgraphs',F))
infiles		<- data.table(F=list.files(indir.phsc, pattern='rda$', full.names=TRUE, recursive=TRUE))
infiles
indir.phsc
home <- '~/Box Sync/OR_Work/Seattle'#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	outdir <- '~/Box Sync/OR_Work/Seattle/analysis_190723/KCHSX'#
	##
	#	extract subgraph taxa	#
	##
	infiles		<- data.table(F=list.files(indir.phsc, pattern='rda$', full.names=TRUE, recursive=TRUE))#
	subset(infiles, grepl('datedsubgraphs',F))
infiles[, SELECT:= gsub('^(.*)subgraphs_([A-Z]+)\\.rda','\\2',basename(F))]
infiles
infiles <- subset(infiles, grepl('datedsubgraphs',F))
infiles
infiles[, ST:= gsub('^Subtype(.*)_([0-9]+)_.*\\.rda','\\1',basename(F))]#
	infiles[, REP:= gsub('^Subtype_(.*)_([0-9]+)_.*\\.rda','\\2',basename(F))]
infiles
infiles[, ST:= gsub('^.*Subtype(.*)_([0-9]+)_.*\\.rda','\\1',basename(F))]#
	infiles[, REP:= gsub('^.*Subtype_(.*)_([0-9]+)_.*\\.rda','\\2',basename(F))]
infiles
infiles[, ST:= gsub('^.*Subtype(^_*)_([0-9]+)_.*\\.rda','\\1',basename(F))]#
	infiles[, REP:= gsub('^.*Subtype(^_*)_([0-9]+)_.*\\.rda','\\2',basename(F))]
infiles
infiles[, ST:= gsub('^.*Subtype([^_]+)_([0-9]+)_.*\\.rda','\\1',basename(F))]#
	infiles[, REP:= gsub('^.*Subtype[^_]+)_([0-9]+)_.*\\.rda','\\2',basename(F))]
infiles
infiles[, ST:= gsub('^.*Subtype([^_]+)_.*\\.rda','\\1',basename(F))]
infiles
infiles[, REP:= gsub('^.ndrm_([0-9]+)_.*\\.rda','\\1',basename(F))]
infiles
infiles[, REP:= gsub('^.*ndrm_([0-9]+)_.*\\.rda','\\1',basename(F))]
infiles
dsubgraphtaxa <- infiles[, {#
				#i<- 1#
				#infile <- infiles[i, F]			#
				infile <- F#
				cat('Process',infile,'\n')#
				load(infile)			#
				subgraph.names <- unlist(sapply( subgraphs, function(subgraph)  rep(subgraph$subgraph.name, length(subgraph$tip.label)) ))#
				subgraph.taxa <- unlist(sapply( subgraphs, function(subgraph)  subgraph$tip.label))				#
				list(	NAME=subgraph.names, #
						TAXA= subgraph.taxa #
				)				#
			}, by=c('ST','REP','SELECT')]
dsubgraphtaxa
#	add meta data from taxa names#
	dsubgraphtaxa[, ID:= as.numeric(gsub('^([A-Z]+)_+PR/RT-([0-9]+)-([0-9]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z_]+)-([0-9]+)$','\\3',TAXA))]#
	dsubgraphtaxa[, LOC:= gsub('^([A-Z]+)_+PR/RT-([0-9]+-[0-9]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z_]+)-([0-9]+)$','\\3',TAXA)]#
	dsubgraphtaxa[, ETH:= gsub('^([A-Z]+)_+PR/RT-([0-9]+-[0-9]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z_]+)-([0-9]+)$','\\4',TAXA)]#
	dsubgraphtaxa[, BORN:= gsub('^([A-Z]+)_+PR/RT-([0-9]+-[0-9]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z_]+)-([0-9]+)$','\\5',TAXA)]#
	dsubgraphtaxa[, SEX:= gsub('^([A-Z]+)_+PR/RT-([0-9]+-[0-9]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z_]+)-([0-9]+)$','\\6',TAXA)]#
	dsubgraphtaxa[, TRM:= gsub('_[M|F]','',gsub('^([A-Z]+)_+PR/RT-([0-9]+-[0-9]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z_]+)-([0-9]+)$','\\7',TAXA))]#
	dsubgraphtaxa[, POSDATE:= as.numeric(gsub('^([A-Z]+)_+PR/RT-([0-9]+-[0-9]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z_]+)-([0-9]+)$','\\8',TAXA))]#
	dsubgraphtaxa[, FULL_NAME:= paste0(ST,'_',REP,'_',SELECT,'_',NAME)]
dsubgraphtaxa
regex.tip.label <- '^([A-Z]+)_+PR/RT-([0-9]+)_([0-9]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z_]+)_([0-9]+)$'#
	dsubgraphtaxa[, ID:= as.numeric(gsub(regex.tip.label,'\\3',TAXA))]
dsubgraphtaxa
dsubgraphtaxa[, LOC:= gsub(regex.tip.label,'\\3',TAXA)]#
	dsubgraphtaxa[, ETH:= gsub(regex.tip.label,'\\4',TAXA)]#
	dsubgraphtaxa[, BORN:= gsub(regex.tip.label,'\\5',TAXA)]#
	dsubgraphtaxa[, SEX:= gsub(regex.tip.label,'\\6',TAXA)]#
	dsubgraphtaxa[, TRM:= gsub('_[M|F]','',gsub(regex.tip.label,'\\7',TAXA))]#
	dsubgraphtaxa[, POSDATE:= as.numeric(gsub(regex.tip.label,'\\8',TAXA))]
dsubgraphtaxa
dsubgraphtaxa[, LOC:= gsub(regex.tip.label,'\\5',TAXA)]#
	dsubgraphtaxa[, ETH:= gsub(regex.tip.label,'\\6',TAXA)]
dsubgraphtaxa
dsubgraphtaxa[, LOC:= gsub(regex.tip.label,'\\4',TAXA)]#
	dsubgraphtaxa[, ETH:= gsub(regex.tip.label,'\\5',TAXA)]
dsubgraphtaxa
dsubgraphtaxa[, BORN:= gsub(regex.tip.label,'\\6',TAXA)]#
	dsubgraphtaxa[, SEX:= gsub(regex.tip.label,'\\7',TAXA)]#
	dsubgraphtaxa[, TRM:= gsub('_[M|F]','',gsub(regex.tip.label,'\\8',TAXA))]#
	dsubgraphtaxa[, POSDATE:= as.numeric(gsub(regex.tip.label,'\\9',TAXA))]
dsubgraphtaxa
dsubgraphtaxa[, FULL_NAME:= paste0(ST,'_',REP,'_',SELECT,'_',NAME)]
dsubgraphtaxa
infile.meta <- file.path(home,'PHSKC-2018-07-09','person.rds')
z<- load('~/Box Sync/OR_Work/Seattle/analysis_191017/misc/180709_sequence_labels.rda')
z
dind
require(data.table)#
	require(ape)#
	require(tidyverse)#
	home <- '~/Box Sync/OR_Work/Seattle'#
	infile.indinfo <- file.path(home,'PHSKC-2018-07-09','person.rds')#
	infile.seqinfo <- file.path(home,'PHSKC-2018-07-09','sequences_meta.rds')	#
	infile.countryinfo <- file.path(home,'analysis_191017','misc/Country_db.rds')#
	infiles.lanl <- file.path(home,'analysis_191017','alignments',c('180709_LANL_Subtype01AE_mafft.fasta','180709_LANL_SubtypeA1_mafft.fasta','180709_LANL_SubtypeB_mafft.fasta','180709_LANL_SubtypeC_mafft.fasta'))#
	infile.subtype <- file.path(home,'analysis_191017','misc','180709_Subtype.csv')#
	outfile.base <- file.path(home,'analysis_191017','misc','180709_')#
	##
	# collect country codes#
	##
	dco <- readRDS(infile.countryinfo)#
	dco <- lapply(seq_len(length(dco)), function(i) tibble(WRLD=names(dco)[i], CNTRY=dco[[i]]))#
	dco <- do.call('rbind',dco)#
	dco <- dco %>% mutate(WRLD=gsub('Unkno','Unknown',gsub('\\.|\\_','',WRLD)))	#
	tmp <- tibble(	CNTRY= c("BO", "SD", "EC", "AG", "DM", "GD", "GY", "VC", "SR", "LC", "UZ", "AZ", "GH", "HT", "LV", "BZ", "MN", "GF", "TJ"),#
					NAME= c("Bolivia","Sudan","Ecuador","Antigua","Dominica","Grenada","Guyana","Saint Vincent","Suriname","Saint Lucia","Uzbekistan","Azerbaijan","Ghana","Haiti","Latvia","Belize","Mongolia","French Guiana","Tajikistan"),#
					WRLD= c("SMAm","NorAf","SMAm","SMAm","SMAm","SMAm","SMAm","SMAm","SMAm","SMAm","Asia","Asia","SSA","SMAm","Europe","SMAm","Asia","SMAm","Asia")#
					)#
	dco <- tmp %>%	#
		select(WRLD, CNTRY) %>%			#
		rbind(dco) %>% #
		mutate(WRLD:= case_when(CNTRY=='MX'~"SMAm",CNTRY=='CA'~'Canada',CNTRY=='GL'~'Canada',CNTRY!='GL'&CNTRY!='CA'&CNTRY!='MX'~WRLD)) %>%		#
		arrange(WRLD, CNTRY)#
	table(dco$WRLD, dco$CNTRY)	#
#
	##
	# read Seattle indidivual data #
	#	#
	dind <- readRDS(infile.indinfo) #
	dind <- dind %>% #
			select(newnum, race, b_yr, birthCountry, gender, sex, sex_with_male_and_female, transm, rsh_county_name, rsa_county_name, cur_county_name) %>%#
			mutate( birthCountry2:= gsub('^\\(([A-Z0-9]+)\\).*$','\\1', birthCountry),#
					county:= case_when(	rsh_county_name!="KING CO."&rsa_county_name!="KING CO."&cur_county_name!="KING CO."~'other',#
										rsh_county_name=="KING CO."|rsa_county_name=="KING CO."|cur_county_name=="KING CO."~'king'),#
					Gender2:= case_when(gender=='FM'~'Trns',#
										gender=='MF'~'Trns',#
										gender=='F'&sex=='F'~'F',#
										gender=='F'&sex=='M'~'Trns',#
										gender=='M'&sex=='M'~'M',#
										gender=='M'&sex=='F'~'Trns'),#
					transm2:= case_when(grepl('MSM',transm)~'MSM',#
										grepl('HETERO',transm)~'HSX',#
										grepl('BLOOD|PERINAT|OTHER',transm)~'OTH',#
										grepl('UNKNOWN',transm)~'UNKNOWN'),#
					race2:= case_when( grepl('Black',race)~'Black',#
									grepl('White',race)~'White',#
									grepl('\\(1\\)Hispanic',race)~'Hispanic',#
									grepl('Hawaiian|Indian|Asian|Multi-race',race)~'Other',#
									grepl('Unknown',race)~'Unknown'#
									)) %>%#
			mutate( birthCountry2:= case_when(	birthCountry2==''~'Unknown',#
												birthCountry2=='X98'~'Unknown',#
												birthCountry2=='X99'~'Unknown',#
												birthCountry2!=''&birthCountry2!='X98'&birthCountry2!='X99'~birthCountry2#
												))
dind
dind <- readRDS(infile.indinfo)
dind
dind <- dind %>% #
			select(newnum, race, b_yr, birthCountry, gender, sex, sex_with_male_and_female, transm, rsh_county_name, rsa_county_name, cur_county_name) %>%#
			mutate( birthCountry2:= gsub('^\\(([A-Z0-9]+)\\).*$','\\1', birthCountry),#
					county:= case_when(	rsh_county_name!="KING CO."&rsa_county_name!="KING CO."&cur_county_name!="KING CO."~'other',#
										rsh_county_name=="KING CO."|rsa_county_name=="KING CO."|cur_county_name=="KING CO."~'king'),#
					Gender2:= case_when(gender=='FM'~'Trns',#
										gender=='MF'~'Trns',#
										gender=='F'&sex=='F'~'F',#
										gender=='F'&sex=='M'~'Trns',#
										gender=='M'&sex=='M'~'M',#
										gender=='M'&sex=='F'~'Trns'),#
					transm2:= case_when(grepl('MSM',transm)~'MSM',#
										grepl('HETERO',transm)~'HSX',#
										grepl('BLOOD|PERINAT|OTHER',transm)~'OTH',#
										grepl('UNKNOWN',transm)~'UNKNOWN'),#
					race2:= case_when( grepl('Black',race)~'Black',#
									grepl('White',race)~'White',#
									grepl('\\(1\\)Hispanic',race)~'Hispanic',#
									grepl('Hawaiian|Indian|Asian|Multi-race',race)~'Other',#
									grepl('Unknown',race)~'Unknown'#
									)) %>%#
			mutate( birthCountry2:= case_when(	birthCountry2==''~'Unknown',#
												birthCountry2=='X98'~'Unknown',#
												birthCountry2=='X99'~'Unknown',#
												birthCountry2!=''&birthCountry2!='X98'&birthCountry2!='X99'~birthCountry2#
												))#
	#	setdiff( dind$birthCountry2, dco$CNTRY )	#
	#	let s not resolve country of birth to world region for now..#
	for(x in colnames(dind))#
	 attr(dind[[x]], "label") <- NULL			#
	#			#
	#table(dind$Gender2, dind$transm2, dind$sex_with_male_and_female) # sex_with_male_and_female does not look very reliable#
#
	##
	# read Seattle sequence data #
	#	#
	dseq <- readRDS(infile.seqinfo)#
	dseq <- dseq %>% filter(type=='PR/RT') %>% select(seqID, newnum, seqy)#
	for(x in colnames(dseq))#
		attr(dseq[[x]], "label") <- NULL	#
	dseq <- dind %>% inner_join(dseq, by='newnum')	#
	dseq <- dseq %>% select(newnum, seqID, seqy, county, Gender2, transm2, race2, birthCountry2)	#
	tmp <- as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE)) %>%#
			rename(seqID:=name, ST:=subtype) %>%#
			select(seqID, ST) %>%#
			mutate(seqID= gsub('PRRT','PR/RT',seqID))#
	dseq <- dseq %>% left_join(tmp, by='seqID')#
	##
	#	collect LANL labels#
	##
	dl <- sapply(seq_along(infiles.lanl), function(i) rownames(read.dna(infiles.lanl[i],format='fa')))#
	dl <- tibble(TAXA=unlist(dl)) %>% #
			filter(!grepl('PR\\/RT',TAXA) & TAXA!='HXB2') %>% #
			mutate(	ST:= sapply(strsplit(TAXA,'.',fixed=TRUE),'[[',1),#
					CNTRY:= sapply(strsplit(TAXA,'.',fixed=TRUE),'[[',2),#
					YEAR:= sapply(strsplit(TAXA,'.',fixed=TRUE),'[[',3),#
					GENBANK:= sapply(strsplit(TAXA,'.',fixed=TRUE),'[[',5)) %>% #
			distinct()#
	dl <- dl %>%#
			filter(grepl('HXB2',TAXA)) %>%#
			mutate(TAXA:='HXB2') %>%#
			rbind(dl)	#
	##
	outfile <- paste0(outfile.base,'sequence_labels.rda')#
	save(dseq, dind, dl, dco, file= outfile)
home <- '~/Box Sync/OR_Work/Seattle'#
	infile.indinfo <- file.path(home,'PHSKC-2018-07-09','person.rds')#
	infile.seqinfo <- file.path(home,'PHSKC-2018-07-09','sequences_meta.rds')	#
	infile.countryinfo <- file.path(home,'analysis_191017','misc/Country_db.rds')#
	infiles.lanl <- file.path(home,'analysis_191017','alignments',c('180709_LANL_Subtype01AE_mafft.fasta','180709_LANL_SubtypeA1_mafft.fasta','180709_LANL_SubtypeB_mafft.fasta','180709_LANL_SubtypeC_mafft.fasta'))#
	infile.subtype <- file.path(home,'analysis_191017','misc','180709_Subtype.csv')#
	outfile.base <- file.path(home,'analysis_191017','misc','180709_')#
	##
	# collect country codes#
	##
	dco <- readRDS(infile.countryinfo)#
	dco <- lapply(seq_len(length(dco)), function(i) tibble(WRLD=names(dco)[i], CNTRY=dco[[i]]))#
	dco <- do.call('rbind',dco)#
	dco <- dco %>% mutate(WRLD=gsub('Unkno','Unknown',gsub('\\.|\\_','',WRLD)))	#
	tmp <- tibble(	CNTRY= c("BO", "SD", "EC", "AG", "DM", "GD", "GY", "VC", "SR", "LC", "UZ", "AZ", "GH", "HT", "LV", "BZ", "MN", "GF", "TJ"),#
					NAME= c("Bolivia","Sudan","Ecuador","Antigua","Dominica","Grenada","Guyana","Saint Vincent","Suriname","Saint Lucia","Uzbekistan","Azerbaijan","Ghana","Haiti","Latvia","Belize","Mongolia","French Guiana","Tajikistan"),#
					WRLD= c("SMAm","NorAf","SMAm","SMAm","SMAm","SMAm","SMAm","SMAm","SMAm","SMAm","Asia","Asia","SSA","SMAm","Europe","SMAm","Asia","SMAm","Asia")#
					)#
	dco <- tmp %>%	#
		select(WRLD, CNTRY) %>%			#
		rbind(dco) %>% #
		mutate(WRLD:= case_when(CNTRY=='MX'~"SMAm",CNTRY=='CA'~'Canada',CNTRY=='GL'~'Canada',CNTRY!='GL'&CNTRY!='CA'&CNTRY!='MX'~WRLD)) %>%		#
		arrange(WRLD, CNTRY)#
	table(dco$WRLD, dco$CNTRY)	#
#
	##
	# read Seattle indidivual data #
	#	#
	dind <- readRDS(infile.indinfo) #
	dind <- dind %>% #
			select(newnum, race, b_yr, birthCountry, gender, sex, sex_with_male_and_female, transm, rsh_county_name, rsa_county_name, cur_county_name) %>%#
			mutate( birthCountry2:= gsub('^\\(([A-Z0-9]+)\\).*$','\\1', birthCountry),#
					county:= case_when(	rsh_county_name!="KING CO."&rsa_county_name!="KING CO."&cur_county_name!="KING CO."~'other',#
										rsh_county_name=="KING CO."|rsa_county_name=="KING CO."|cur_county_name=="KING CO."~'king'),#
					Gender2:= case_when(gender=='FM'~'Trns',#
										gender=='MF'~'Trns',#
										gender=='F'&sex=='F'~'F',#
										gender=='F'&sex=='M'~'Trns',#
										gender=='M'&sex=='M'~'M',#
										gender=='M'&sex=='F'~'Trns'),#
					transm2:= case_when(grepl('MSM',transm)~'MSM',#
										grepl('HETERO',transm)~'HSX',#
										grepl('BLOOD|PERINAT|OTHER',transm)~'OTH',#
										grepl('UNKNOWN',transm)~'UNKNOWN'),#
					race2:= case_when( grepl('Black',race)~'Black',#
									grepl('White',race)~'White',#
									grepl('\\(1\\)Hispanic',race)~'Hispanic',#
									grepl('Hawaiian|Indian|Asian|Multi-race',race)~'Other',#
									grepl('Unknown',race)~'Unknown'#
									)) %>%#
			mutate( birthCountry2:= case_when(	birthCountry2==''~'Unknown',#
												birthCountry2=='X98'~'Unknown',#
												birthCountry2=='X99'~'Unknown',#
												birthCountry2!=''&birthCountry2!='X98'&birthCountry2!='X99'~birthCountry2#
												))#
	#	setdiff( dind$birthCountry2, dco$CNTRY )	#
	#	let s not resolve country of birth to world region for now..#
	for(x in colnames(dind))#
	 attr(dind[[x]], "label") <- NULL			#
	#			#
	#table(dind$Gender2, dind$transm2, dind$sex_with_male_and_female) # sex_with_male_and_female does not look very reliable#
#
	##
	# read Seattle sequence data #
	#	#
	dseq <- readRDS(infile.seqinfo)#
	dseq <- dseq %>% filter(type=='PR/RT') %>% select(seqID, newnum, seqy)#
	for(x in colnames(dseq))#
		attr(dseq[[x]], "label") <- NULL	#
	dseq <- dind %>% inner_join(dseq, by='newnum')	#
	dseq <- dseq %>% select(newnum, seqID, seqy, county, Gender2, transm2, race2, birthCountry2)
as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE))
tmp <- as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE)) %>%#
			rename(seqID:=name, ST:=subtype) %>%#
			select(seqID, ST) %>%#
			mutate(seqID= gsub('PRRT','PR/RT',seqID))
as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE)) %>%#
			rename(seqID:=name, ST:=subtype) %>%#
			select(seqID, ST)
as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE)) %>%#
			rename(seqID=name, ST=subtype)
as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE))
require(data.table)#
	require(ape)#
	require(tidyverse)
as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE))
as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE)) %>%#
			rename(seqID=name, ST=subtype)
require(data.table)#
	require(tidyverse)#
	require(ape)#
	require(phytools)#
	require(treedater)#
	home <- '~/Box Sync/OR_Work/Seattle'#
	infile.seqinfo <- file.path(home,'PHSKC-2018-07-09','sequences_meta.rds')	#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	infiles.phsc <- data.table(F=list.files(indir.phsc, pattern='workspace.rda$', full.names=TRUE, recursive=TRUE))#
	infiles.phsc <- subset(infiles.phsc, grepl('000',F))#
	alignment.length <- 1000#
	##
	# read Seattle sampling data #
	##
	dseq <- readRDS(infile.seqinfo) #
	dseq <- dseq %>% #
			select(seqID, newnum, type, seqy, seqm) %>%#
			mutate( SEQ_DATE:= seqy + (seqm-1)/12 + 15/365,#
					SEQ_DATE_LOWER:= seqy + (seqm-1)/12,#
					SEQ_DATE_UPPER:= seqy + (seqm-1)/12 + 30/365#
					) %>%#
			select(-seqy, -seqm) %>%#
			rename(TAXA= seqID, PID= newnum, TYPE=type)#
	dseq <- as.data.table(dseq)
infiles.phsc
i<- 4#
		infile <- infiles.phsc[i,F]	#
		load(infile)#
		ph <- phyloscanner.trees[[1]][['tree']]#
		stopifnot( !any( ph$tip.label=='' ) )
str(ph)
host <- 'KC'							#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )
mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]
any(is.na(mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]))
stopifnot( !any(is.na(mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ])) )
dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		#	add Seattle sequence dates#
		dph <- merge(dph, dseq, by='TAXA', all.x=TRUE)#
		#	extract GenBank sequence dates from taxa names where possible #
		dph[, GENBANK_ID:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\5',TAXA)]#
		dph[, GENBANK_SEQDATE:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\3',TAXA)]#
		set(dph, dph[, which(GENBANK_SEQDATE=='-' | !is.na(SEQ_DATE))],'GENBANK_SEQDATE',NA_character_)	#
		set(dph, NULL, 'GENBANK_SEQDATE_LOWER', dph[, as.numeric(GENBANK_SEQDATE) ])#
		set(dph, NULL, 'GENBANK_SEQDATE_UPPER', dph[, as.numeric(GENBANK_SEQDATE) + 364/365 ])	#
		set(dph, NULL, 'GENBANK_SEQDATE', dph[, as.numeric(GENBANK_SEQDATE) + 1/2 ])#
		tmp <- dph[, which(is.na(SEQ_DATE))]#
		set(dph, tmp, 'SEQ_DATE', dph[tmp, GENBANK_SEQDATE])#
		set(dph, tmp, 'SEQ_DATE_LOWER', dph[tmp, GENBANK_SEQDATE_LOWER])#
		set(dph, tmp, 'SEQ_DATE_UPPER', dph[tmp, GENBANK_SEQDATE_UPPER])#
		set(dph, NULL, c('GENBANK_SEQDATE','GENBANK_SEQDATE_LOWER','GENBANK_SEQDATE_UPPER'), NULL)	#
		#	drop tips #
		dph.old <- subset(dph, select=c(TAXA, SEQ_DATE, SEQ_DATE_LOWER, SEQ_DATE_UPPER))	#
		tmp <- subset(dph, is.na(SEQ_DATE))[, TAXA_ID]#
		cat('Dropping tips without sampling date from ', infile,' n=', length(tmp), 'of Ntips=', Ntip(ph), '\n')
phyloscanner.to.simmap(ph)
require(data.table)#
	require(tidyverse)#
	require(ape)#
	require(phytools)#
	require(treedater)#
	home <- '~/Box Sync/OR_Work/Seattle'#
	infile.seqinfo <- file.path(home,'PHSKC-2018-07-09','sequences_meta.rds')	#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	infiles.phsc <- data.table(F=list.files(indir.phsc, pattern='workspace.rda$', full.names=TRUE, recursive=TRUE))#
	infiles.phsc <- subset(infiles.phsc, grepl('000',F))#
	alignment.length <- 1000#
	##
	# read Seattle sampling data #
	##
	dseq <- readRDS(infile.seqinfo) #
	dseq <- dseq %>% #
			select(seqID, newnum, type, seqy, seqm) %>%#
			mutate( SEQ_DATE:= seqy + (seqm-1)/12 + 15/365,#
					SEQ_DATE_LOWER:= seqy + (seqm-1)/12,#
					SEQ_DATE_UPPER:= seqy + (seqm-1)/12 + 30/365#
					) %>%#
			select(-seqy, -seqm) %>%#
			rename(TAXA= seqID, PID= newnum, TYPE=type)#
	dseq <- as.data.table(dseq)
i<- 4#
		infile <- infiles.phsc[i,F]	#
		load(infile)#
		ph <- phyloscanner.trees[[1]][['tree']]#
		stopifnot( !any( ph$tip.label=='' ) )#
		host <- 'KC'							#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		stopifnot( !any(is.na(mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ])) )	#
		##
		#	drop tips without sequence dates, #
		#	while conserving the ancestral state reconstructions#
		##
		#	extract taxa names#
		dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		#	add Seattle sequence dates#
		dph <- merge(dph, dseq, by='TAXA', all.x=TRUE)#
		#	extract GenBank sequence dates from taxa names where possible #
		dph[, GENBANK_ID:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\5',TAXA)]#
		dph[, GENBANK_SEQDATE:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\3',TAXA)]#
		set(dph, dph[, which(GENBANK_SEQDATE=='-' | !is.na(SEQ_DATE))],'GENBANK_SEQDATE',NA_character_)	#
		set(dph, NULL, 'GENBANK_SEQDATE_LOWER', dph[, as.numeric(GENBANK_SEQDATE) ])#
		set(dph, NULL, 'GENBANK_SEQDATE_UPPER', dph[, as.numeric(GENBANK_SEQDATE) + 364/365 ])	#
		set(dph, NULL, 'GENBANK_SEQDATE', dph[, as.numeric(GENBANK_SEQDATE) + 1/2 ])#
		tmp <- dph[, which(is.na(SEQ_DATE))]#
		set(dph, tmp, 'SEQ_DATE', dph[tmp, GENBANK_SEQDATE])#
		set(dph, tmp, 'SEQ_DATE_LOWER', dph[tmp, GENBANK_SEQDATE_LOWER])#
		set(dph, tmp, 'SEQ_DATE_UPPER', dph[tmp, GENBANK_SEQDATE_UPPER])#
		set(dph, NULL, c('GENBANK_SEQDATE','GENBANK_SEQDATE_LOWER','GENBANK_SEQDATE_UPPER'), NULL)	#
		#	drop tips #
		dph.old <- subset(dph, select=c(TAXA, SEQ_DATE, SEQ_DATE_LOWER, SEQ_DATE_UPPER))	#
		tmp <- subset(dph, is.na(SEQ_DATE))[, TAXA_ID]#
		cat('Dropping tips without sampling date from ', infile,' n=', length(tmp), 'of Ntips=', Ntip(ph), '\n')
phyloscanner.to.simmap(ph)
require(data.table)#
	require(tidyverse)#
	require(ape)#
	require(phytools)#
	require(treedater)#
	require(phyloscannerR)#
	home <- '~/Box Sync/OR_Work/Seattle'#
	infile.seqinfo <- file.path(home,'PHSKC-2018-07-09','sequences_meta.rds')	#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	infiles.phsc <- data.table(F=list.files(indir.phsc, pattern='workspace.rda$', full.names=TRUE, recursive=TRUE))#
	infiles.phsc <- subset(infiles.phsc, grepl('000',F))#
	alignment.length <- 1000#
	##
	# read Seattle sampling data #
	##
	dseq <- readRDS(infile.seqinfo) #
	dseq <- dseq %>% #
			select(seqID, newnum, type, seqy, seqm) %>%#
			mutate( SEQ_DATE:= seqy + (seqm-1)/12 + 15/365,#
					SEQ_DATE_LOWER:= seqy + (seqm-1)/12,#
					SEQ_DATE_UPPER:= seqy + (seqm-1)/12 + 30/365#
					) %>%#
			select(-seqy, -seqm) %>%#
			rename(TAXA= seqID, PID= newnum, TYPE=type)#
	dseq <- as.data.table(dseq)
i<- 4#
		infile <- infiles.phsc[i,F]	#
		load(infile)#
		ph <- phyloscanner.trees[[1]][['tree']]#
		stopifnot( !any( ph$tip.label=='' ) )#
		host <- 'KC'							#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		stopifnot( !any(is.na(mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ])) )	#
		##
		#	drop tips without sequence dates, #
		#	while conserving the ancestral state reconstructions#
		##
		#	extract taxa names#
		dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		#	add Seattle sequence dates#
		dph <- merge(dph, dseq, by='TAXA', all.x=TRUE)#
		#	extract GenBank sequence dates from taxa names where possible #
		dph[, GENBANK_ID:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\5',TAXA)]#
		dph[, GENBANK_SEQDATE:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\3',TAXA)]#
		set(dph, dph[, which(GENBANK_SEQDATE=='-' | !is.na(SEQ_DATE))],'GENBANK_SEQDATE',NA_character_)	#
		set(dph, NULL, 'GENBANK_SEQDATE_LOWER', dph[, as.numeric(GENBANK_SEQDATE) ])#
		set(dph, NULL, 'GENBANK_SEQDATE_UPPER', dph[, as.numeric(GENBANK_SEQDATE) + 364/365 ])	#
		set(dph, NULL, 'GENBANK_SEQDATE', dph[, as.numeric(GENBANK_SEQDATE) + 1/2 ])#
		tmp <- dph[, which(is.na(SEQ_DATE))]#
		set(dph, tmp, 'SEQ_DATE', dph[tmp, GENBANK_SEQDATE])#
		set(dph, tmp, 'SEQ_DATE_LOWER', dph[tmp, GENBANK_SEQDATE_LOWER])#
		set(dph, tmp, 'SEQ_DATE_UPPER', dph[tmp, GENBANK_SEQDATE_UPPER])#
		set(dph, NULL, c('GENBANK_SEQDATE','GENBANK_SEQDATE_LOWER','GENBANK_SEQDATE_UPPER'), NULL)	#
		#	drop tips #
		dph.old <- subset(dph, select=c(TAXA, SEQ_DATE, SEQ_DATE_LOWER, SEQ_DATE_UPPER))	#
		tmp <- subset(dph, is.na(SEQ_DATE))[, TAXA_ID]#
		cat('Dropping tips without sampling date from ', infile,' n=', length(tmp), 'of Ntips=', Ntip(ph), '\n')
phyloscanner.to.simmap(ph)
ph <- phyloscanner.to.simmap(ph)	#
		ph <- phytools:::drop.tip.simmap(ph, ph$tip.label[tmp])#
		ph <- simmap.to.phyloscanner(ph)
host <- 'KC'							#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		stopifnot( !any(is.na(mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ])) )
host <- 'KC'							#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )
mrcas
attr(ph, 'INDIVIDUAL')[mrcas]
mrcas <- mrcas[ is.na(attr(ph, 'INDIVIDUAL')[mrcas]) ]
mrcas
Descendants(ph, mrcas[1], type='tip')
require(phytools)
Descendants(ph, mrcas[1], type='tip')
require(phangorn)
Descendants(ph, mrcas[1], type='tip')
Ntip(ph)
ph$tip.label(462)
ph$tip.label[462]
Descendants(ph, mrcas[2], type='tip')
ph$tip.label[655]
host
i<- 4#
		infile <- infiles.phsc[i,F]	#
		load(infile)#
		ph <- phyloscanner.trees[[1]][['tree']]#
		stopifnot( !any( ph$tip.label=='' ) )#
		pho <- copy(ph)#
		host <- 'KC'							#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ is.na(attr(ph, 'INDIVIDUAL')[mrcas]) ]
mrcas
stopifnot( length(mrcas)==0 )
dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		#	add Seattle sequence dates#
		dph <- merge(dph, dseq, by='TAXA', all.x=TRUE)#
		#	extract GenBank sequence dates from taxa names where possible #
		dph[, GENBANK_ID:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\5',TAXA)]#
		dph[, GENBANK_SEQDATE:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\3',TAXA)]#
		set(dph, dph[, which(GENBANK_SEQDATE=='-' | !is.na(SEQ_DATE))],'GENBANK_SEQDATE',NA_character_)	#
		set(dph, NULL, 'GENBANK_SEQDATE_LOWER', dph[, as.numeric(GENBANK_SEQDATE) ])#
		set(dph, NULL, 'GENBANK_SEQDATE_UPPER', dph[, as.numeric(GENBANK_SEQDATE) + 364/365 ])	#
		set(dph, NULL, 'GENBANK_SEQDATE', dph[, as.numeric(GENBANK_SEQDATE) + 1/2 ])#
		tmp <- dph[, which(is.na(SEQ_DATE))]#
		set(dph, tmp, 'SEQ_DATE', dph[tmp, GENBANK_SEQDATE])#
		set(dph, tmp, 'SEQ_DATE_LOWER', dph[tmp, GENBANK_SEQDATE_LOWER])#
		set(dph, tmp, 'SEQ_DATE_UPPER', dph[tmp, GENBANK_SEQDATE_UPPER])#
		set(dph, NULL, c('GENBANK_SEQDATE','GENBANK_SEQDATE_LOWER','GENBANK_SEQDATE_UPPER'), NULL)	#
		#	drop tips #
		dph.old <- subset(dph, select=c(TAXA, SEQ_DATE, SEQ_DATE_LOWER, SEQ_DATE_UPPER))	#
		tmp <- subset(dph, is.na(SEQ_DATE))[, TAXA_ID]#
		cat('Dropping tips without sampling date from ', infile,' n=', length(tmp), 'of Ntips=', Ntip(ph), '\n')#
		ph <- phyloscanner.to.simmap(ph)
str(ph)
ph$tip.label[655]
which(grepl('JN630990', ph$tip.label))
z1<-which(grepl('JN630990', ph$tip.label))
attr(ph,'SUBGRAPH_MRCA')[z1]
attr(ph,'INDIVIDUAL')[z1]
i<- 4#
		infile <- infiles.phsc[i,F]	#
		load(infile)#
		ph <- phyloscanner.trees[[1]][['tree']]#
		stopifnot( !any( ph$tip.label=='' ) )
z1<-which(grepl('JN630990', ph$tip.label))#
		attr(ph,'SUBGRAPH_MRCA')[z1]#
		attr(ph,'INDIVIDUAL')[z1]
attr(ph,'INDIVIDUAL')
extract.subgraph<- function(ph, mrca)#
{#
	stopifnot( any(class(ph)=='simmap') )#
	stopifnot( c("SPLIT","INDIVIDUAL","BRANCH_COLOURS","SUBGRAPH_MRCA")%in%names(attributes(ph)) )#
	subgraph.name <- as.character(attr(ph, 'SPLIT')[mrca])#
	host <- as.character(attr(ph, "INDIVIDUAL")[mrca])#
	subgraph.root.edge <- ph$edge.length[ which( ph$edge[,2]==mrca ) ]#
	subgraph.parent.state <- as.character(attr(ph, "BRANCH_COLOURS")[ ph$edge[ph$edge[,2]==mrca,1] ])#
	print( subgraph.parent.state )#
	stopifnot( is.na(subgraph.parent.state) || subgraph.parent.state!=host )#
	if(mrca<=Ntip(ph))#
	{#
		subgraph<- list(	edge= matrix(nrow=0, ncol=2), #
				edge.length=vector('numeric',0),#
				Nnode=0,#
				tip.label=ph$tip.label[mrca],#
				maps= vector('list',0),#
				mapped.edge= matrix(nrow=0, ncol=0),#
				node.states= matrix(nrow=0, ncol=2)#
		)#
		#attr(subgraph,'class') <- c( "phylo")#
		#attr(subgraph, "map.order") <- "right-to-left"#
		#attr(subgraph, "order") <- "cladewise"		#
	}#
	if(mrca>Ntip(ph))#
	{#
		subgraph <- phytools:::extract.clade.simmap(ph, mrca)#
		subgraph.root <- Ntip(subgraph)+1L#
		descendants <- Descendants(subgraph, subgraph.root, type='all')#
		tmp <- sapply(descendants, function(x) which(subgraph$edge[,2]==x))#
		descendants.states <- subgraph[['node.states']][tmp,2]#
		descendants.not.in.subgraph <- descendants[ descendants.states!=subgraph.name ]#
		if(length(descendants.not.in.subgraph))#
		{#
			# find all tips of descendants.not.in.subgraph, and remove the corresponding tips, which will remove the subtree for each descendant#
			tips.not.in.subgraph <- sort(unique(unlist(Descendants(subgraph, descendants.not.in.subgraph, type='tips'))))#
			subgraph <- ape:::drop.tip(subgraph, tips.not.in.subgraph)#
			subgraph[['maps']] <- NULL#
			subgraph[['mapped.edge']] <- NULL#
			subgraph[['node.states']] <- NULL#
			attr(subgraph,'class') <- c( "phylo")#
			attr(subgraph, "map.order") <- NULL#
			attr(subgraph, "order") <- NULL#
			attr(subgraph, "SPLIT") <- NULL#
			attr(subgraph, "INDIVIDUAL") <- NULL#
			attr(subgraph, "BRANCH_COLOURS") <- NULL#
			attr(subgraph, "SUBGRAPH_MRCA") <- NULL			#
		}		#
	}#
	subgraph[['subgraph.name']]<- subgraph.name#
	subgraph[['subgraph.root.edge']]<- subgraph.root.edge#
	subgraph[['subgraph.parent.state']]<- subgraph.parent.state#
	subgraph	#
}
mrca<- 7997#
		extract.subgraph(ph, mrca)
extract.subgraph<- function(ph, mrca)#
{#
	stopifnot( any(class(ph)=='simmap') )#
	stopifnot( c("SPLIT","INDIVIDUAL","BRANCH_COLOURS","SUBGRAPH_MRCA")%in%names(attributes(ph)) )#
	subgraph.name <- as.character(attr(ph, 'SPLIT')[mrca])#
	host <- as.character(attr(ph, "INDIVIDUAL")[mrca])#
	subgraph.root.edge <- ph$edge.length[ which( ph$edge[,2]==mrca ) ]#
	subgraph.parent.state <- as.character(attr(ph, "BRANCH_COLOURS")[ ph$edge[ph$edge[,2]==mrca,1] ])#
	print( subgraph.parent.state )#
	print( as.character(attr(ph, "BRANCH_COLOURS")[ ph$edge[ph$edge[,2]==mrca,2] ]) )#
	stopifnot( is.na(subgraph.parent.state) || subgraph.parent.state!=host )#
	if(mrca<=Ntip(ph))#
	{#
		subgraph<- list(	edge= matrix(nrow=0, ncol=2), #
				edge.length=vector('numeric',0),#
				Nnode=0,#
				tip.label=ph$tip.label[mrca],#
				maps= vector('list',0),#
				mapped.edge= matrix(nrow=0, ncol=0),#
				node.states= matrix(nrow=0, ncol=2)#
		)#
		#attr(subgraph,'class') <- c( "phylo")#
		#attr(subgraph, "map.order") <- "right-to-left"#
		#attr(subgraph, "order") <- "cladewise"		#
	}#
	if(mrca>Ntip(ph))#
	{#
		subgraph <- phytools:::extract.clade.simmap(ph, mrca)#
		subgraph.root <- Ntip(subgraph)+1L#
		descendants <- Descendants(subgraph, subgraph.root, type='all')#
		tmp <- sapply(descendants, function(x) which(subgraph$edge[,2]==x))#
		descendants.states <- subgraph[['node.states']][tmp,2]#
		descendants.not.in.subgraph <- descendants[ descendants.states!=subgraph.name ]#
		if(length(descendants.not.in.subgraph))#
		{#
			# find all tips of descendants.not.in.subgraph, and remove the corresponding tips, which will remove the subtree for each descendant#
			tips.not.in.subgraph <- sort(unique(unlist(Descendants(subgraph, descendants.not.in.subgraph, type='tips'))))#
			subgraph <- ape:::drop.tip(subgraph, tips.not.in.subgraph)#
			subgraph[['maps']] <- NULL#
			subgraph[['mapped.edge']] <- NULL#
			subgraph[['node.states']] <- NULL#
			attr(subgraph,'class') <- c( "phylo")#
			attr(subgraph, "map.order") <- NULL#
			attr(subgraph, "order") <- NULL#
			attr(subgraph, "SPLIT") <- NULL#
			attr(subgraph, "INDIVIDUAL") <- NULL#
			attr(subgraph, "BRANCH_COLOURS") <- NULL#
			attr(subgraph, "SUBGRAPH_MRCA") <- NULL			#
		}		#
	}#
	subgraph[['subgraph.name']]<- subgraph.name#
	subgraph[['subgraph.root.edge']]<- subgraph.root.edge#
	subgraph[['subgraph.parent.state']]<- subgraph.parent.state#
	subgraph	#
}
mrca<- 7997#
		extract.subgraph(ph, mrca)
require(data.table)#
	require(tidyverse)#
	require(ape)#
	require(phytools)#
	require(treedater)#
	require(phyloscannerR)#
	home <- '~/Box Sync/OR_Work/Seattle'#
	infile.seqinfo <- file.path(home,'PHSKC-2018-07-09','sequences_meta.rds')	#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	infiles.phsc <- data.table(F=list.files(indir.phsc, pattern='workspace.rda$', full.names=TRUE, recursive=TRUE))#
	infiles.phsc <- subset(infiles.phsc, grepl('000',F))#
	alignment.length <- 1000#
	##
	# read Seattle sampling data #
	##
	dseq <- readRDS(infile.seqinfo) #
	dseq <- dseq %>% #
			select(seqID, newnum, type, seqy, seqm) %>%#
			mutate( SEQ_DATE:= seqy + (seqm-1)/12 + 15/365,#
					SEQ_DATE_LOWER:= seqy + (seqm-1)/12,#
					SEQ_DATE_UPPER:= seqy + (seqm-1)/12 + 30/365#
					) %>%#
			select(-seqy, -seqm) %>%#
			rename(TAXA= seqID, PID= newnum, TYPE=type)#
	dseq <- as.data.table(dseq)
i<- 4#
		infile <- infiles.phsc[i,F]	#
		load(infile)#
		ph <- phyloscanner.trees[[1]][['tree']]#
		stopifnot( !any( ph$tip.label=='' ) )		#
		##
		#	drop tips without sequence dates, #
		#	while conserving the ancestral state reconstructions#
		##
		#	extract taxa names#
		dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		#	add Seattle sequence dates#
		dph <- merge(dph, dseq, by='TAXA', all.x=TRUE)#
		#	extract GenBank sequence dates from taxa names where possible #
		dph[, GENBANK_ID:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\5',TAXA)]#
		dph[, GENBANK_SEQDATE:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\3',TAXA)]#
		set(dph, dph[, which(GENBANK_SEQDATE=='-' | !is.na(SEQ_DATE))],'GENBANK_SEQDATE',NA_character_)	#
		set(dph, NULL, 'GENBANK_SEQDATE_LOWER', dph[, as.numeric(GENBANK_SEQDATE) ])#
		set(dph, NULL, 'GENBANK_SEQDATE_UPPER', dph[, as.numeric(GENBANK_SEQDATE) + 364/365 ])	#
		set(dph, NULL, 'GENBANK_SEQDATE', dph[, as.numeric(GENBANK_SEQDATE) + 1/2 ])#
		tmp <- dph[, which(is.na(SEQ_DATE))]#
		set(dph, tmp, 'SEQ_DATE', dph[tmp, GENBANK_SEQDATE])#
		set(dph, tmp, 'SEQ_DATE_LOWER', dph[tmp, GENBANK_SEQDATE_LOWER])#
		set(dph, tmp, 'SEQ_DATE_UPPER', dph[tmp, GENBANK_SEQDATE_UPPER])#
		set(dph, NULL, c('GENBANK_SEQDATE','GENBANK_SEQDATE_LOWER','GENBANK_SEQDATE_UPPER'), NULL)	#
		#	drop tips #
		dph.old <- subset(dph, select=c(TAXA, SEQ_DATE, SEQ_DATE_LOWER, SEQ_DATE_UPPER))	#
		tmp <- subset(dph, is.na(SEQ_DATE))[, TAXA_ID]#
		cat('Dropping tips without sampling date from ', infile,' n=', length(tmp), 'of Ntips=', Ntip(ph), '\n')#
		ph <- phyloscanner.to.simmap(ph)	#
		ph <- phytools:::drop.tip.simmap(ph, ph$tip.label[tmp])#
		ph <- simmap.to.phyloscanner(ph)		#
		##
		#	date tree#
		#	#
		#	make data.table of sequence sampling times#
		dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		dph <- merge(dph, dph.old, by= 'TAXA')#
		stopifnot( !any(is.na(dph$SEQ_DATE)) )#
		dph <- dph[order(TAXA_ID),]#
		#	get into format needed for tree.dater	#
		#sampling.times <- dph$SEQ_DATE#
		#names(sampling.times) <- dph$TAXA_LABEL	#
		sampling.times.init <- dph$SEQ_DATE#
		names(sampling.times.init) <- dph$TAXA_LABEL#
		sampling.times.bounds <- as.data.frame(subset(dph, select=c(SEQ_DATE_LOWER, SEQ_DATE_UPPER)))#
		rownames(sampling.times.bounds) <- dph$TAXA_LABEL		#
		colnames(sampling.times.bounds) <- c('lower','upper')
sampling.times.bounds
sampling.times.init
require(data.table)	#
	require(phyloscannerR)#
	home <- '~/Box Sync/OR_Work/Seattle/analysis_191017'#
	#home <- '/rds/general/project/ratmann_seattle_data_analysis/live/olli_191017'		#
	indir <- file.path(home,'phyloscanner_dated')#
	outdir <- file.path(home,'phyloscanner_dated')#
	infiles <- data.table(F_PHSC=list.files(indir, pattern='collapsed_workspace.rda$', full.names=TRUE, recursive=TRUE))#
	infiles[, BASENAME:= gsub('collapsed_workspace.rda$','',basename(F_PHSC))]#
	tmp <- data.table(F_TREE=list.files(indir, pattern='collapsed_dated.newick$', full.names=TRUE, recursive=TRUE))#
	tmp[, BASENAME:= gsub('collapsed_dated.newick$','',basename(F_TREE))]#
	infiles <- merge(infiles, tmp, by='BASENAME', all.x=TRUE)
infiles
stopifnot( nrow(subset(infiles, is.na(F_TREE)))==0 )
i<- 1#
		cat('\nProcess ',infiles[i,F_TREE])#
		#	load data#
		load(infiles[i,F_PHSC])#
		ph.dated <- read.tree(infiles[i,F_TREE])		#
		stopifnot( all(  ph.dated$tip.label == ph$tip.label ) )#
		stopifnot( all( ph.dated$edge == ph$edge ) )
ph$edge.length <- ph.dated$edge.length#
		#	plot dated tree to spot obvious errors#
		outfile <- gsub('collapsed_workspace\\.rda','annotated_dated_tree.pdf',infile)#
		tmp <- vector('list')#
		tmp[['tree']] <- ph#
		tmp[['tree']][['node.states']] <- tmp[['tree']][['mapped.edge']] <- tmp[['tree']][['maps']] <- NULL#
		attr(tmp[['tree']],'map.order') <- NULL#
		attr(tmp[['tree']],'class') <- 'phylo'#
		tmp[['read.counts']] <- rep(1, Ntip(ph))
outfile
outfile <- gsub('collapsed_workspace\\.rda','annotated_dated_tree.pdf',infiles[i,F_PHSC])
outfile
write.annotated.tree(tmp, outfile, format="pdf", pdf.scale.bar.width = 0.01, pdf.w = 40, pdf.hm = 0.2, verbose = FALSE)
outfile <- gsub('collapsed_workspace\\.rda','annotated_dated_tree.rda',infiles[i,F_PHSC])#
		save(ph, file=outfile)
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.pipeline.ali2phsc.Rmd')
home <- '~/Box Sync/OR_Work/Seattle/analysis_191017'#
	indir.phsc	<- file.path(home,'phyloscanner_dated')#
	infiles.phsc <- data.table(F=list.files(indir.phsc, pattern='_annotated_dated_tree.rda$', full.names=TRUE, recursive=TRUE))#
	control	<- list( 	localstate.regex='^KCHSX.*', #
						keep.n.nonlocal.tips=2,#
						remove.localstate.subtrees.of.size.1= 1#
						)#
	verbose <- 1#
	localstate.regex <- control$localstate.regex#
	keep.n.nonlocal.tips <- control$keep.n.nonlocal.tips#
	remove.localstate.subtrees.of.size.1 <- control$remove.localstate.subtrees.of.size.1
infiles.phsc
require(data.table)#
	require(phangorn)#
	require(ggplot2)#
	require(reshape)#
	require(phyloscannerR)#
	#	working directory with phyloscanner output#
	home <- '/Users/Oliver/Box Sync/OR_Work/Seattle/analysis_191017'#
	indir.phsc	<- file.path(home,'phyloscanner_dated')#
	infiles		<- data.table(F=list.files(indir.phsc, pattern='_annotated_dated_tree.rda$', full.names=TRUE, recursive=TRUE))	#
	infiles[, SELECT:= gsub('^.*_rerooted_([A-Za-z0-9]+)_.*$','\\1',basename(F))]
infiles
require(data.table)	#
	require(phyloscannerR)#
	home <- '~/Box Sync/OR_Work/Seattle/analysis_191017'#
	#home <- '/rds/general/project/ratmann_seattle_data_analysis/live/olli_191017'		#
	indir <- file.path(home,'phyloscanner_dated')#
	infiles <- data.table(F_PHSC=list.files(indir, pattern='collapsed_workspace.rda$', full.names=TRUE, recursive=TRUE))#
	infiles[, BASENAME:= gsub('collapsed_workspace.rda$','',basename(F_PHSC))]#
	tmp <- data.table(F_TREE=list.files(indir, pattern='collapsed_dated.newick$', full.names=TRUE, recursive=TRUE))#
	tmp[, BASENAME:= gsub('collapsed_dated.newick$','',basename(F_TREE))]#
	infiles <- merge(infiles, tmp, by='BASENAME', all.x=TRUE)	#
	stopifnot( nrow(subset(infiles, is.na(F_TREE)))==0 )
infiles
require(data.table)	#
	require(phyloscannerR)#
	home <- '~/Box Sync/OR_Work/Seattle/analysis_191017'#
	#home <- '/rds/general/project/ratmann_seattle_data_analysis/live/olli_191017'		#
	indir <- file.path(home,'phyloscanner_dated')#
	infiles <- data.table(F_PHSC=list.files(indir, pattern='collapsed_workspace.rda$', full.names=TRUE, recursive=TRUE))#
	infiles[, BASENAME:= gsub('collapsed_workspace.rda$','',basename(F_PHSC))]#
	tmp <- data.table(F_TREE=list.files(indir, pattern='collapsed_dated.newick$', full.names=TRUE, recursive=TRUE))#
	tmp[, BASENAME:= gsub('collapsed_dated.newick$','',basename(F_TREE))]#
	infiles <- merge(infiles, tmp, by='BASENAME', all.x=TRUE)	#
	stopifnot( nrow(subset(infiles, is.na(F_TREE)))==0 )
infiles
subset(infiles, is.na(F_TREE))
i<- 1
infiles <- subset(infiles, is.na(F_TREE))
infiles
require(hivclust)
require(big.phylo)
cmd.treedater.script
PR.TREEDATER.SCRIPT			<- paste('Rscript', system.file(package=PR.PACKAGE, "treedater.Rscript"))
PR.PACKAGE					<- "big.phylo"
PR.TREEDATER.SCRIPT			<- paste('Rscript', system.file(package=PR.PACKAGE, "treedater.Rscript"))
cmd.treedater.script<- function(infile.tree, infile.dates, control= list(outfile=gsub('.newick$','_dated.newick',infile.tree), ali.len=1e3, root=NA, omega0=NA, temporalConstraints=TRUE, strictClock=FALSE, estimateSampleTimes=NA, abstol=1e-4, maxit=100, numStartConditions=1), pr=PR.TREEDATER.SCRIPT)#
{#
	stopifnot('ali.len'%in%names(control))#
	stopifnot('outfile'%in%names(control))#
	cmd	<- paste(pr, ' --infile.dates "',infile.dates,'" --infile.tree "',infile.tree,'" --outfile "', control$outfile,'"', sep='')	#
	if('ali.len'%in%names(control) && !is.na(control$ali.len))#
		cmd	<- paste(cmd, ' --ali.len ', control$ali.len, sep='')#
	if('root'%in%names(control) && !is.na(control$root))	#
		cmd	<- paste(cmd, ' --root "', control$root, '"', sep='')	#
	if('omega0'%in%names(control) && !is.na(control$omega0))#
		cmd	<- paste(cmd, ' --omega0 ', control$omega0, sep='')#
	if('temporalConstraints'%in%names(control) && !is.na(control$temporalConstraints))#
		cmd	<- paste(cmd, ' --temporalConstraints ', control$temporalConstraints, sep='')#
	if('strictClock'%in%names(control) && !is.na(control$strictClock))#
		cmd	<- paste(cmd, ' --strictClock ', control$strictClock, sep='')#
	if('estimateSampleTimes'%in%names(control) && !is.na(control$estimateSampleTimes))#
		cmd	<- paste(cmd, ' --estimateSampleTimes "', control$estimateSampleTimes, '"', sep='')#
	if('abstol'%in%names(control) && !is.na(control$abstol))#
		cmd	<- paste(cmd, ' --abstol ', control$abstol, sep='')#
	if('maxit'%in%names(control) && !is.na(control$maxit))#
		cmd	<- paste(cmd, ' --maxit ', control$maxit, sep='')#
	if('numStartConditions'%in%names(control) && !is.na(control$numStartConditions))#
		cmd	<- paste(cmd, ' --numStartConditions ', control$numStartConditions, sep='')	#
	cmd#
}
home <- '~/Box Sync/OR_Work/Seattle/analysis_191017'
indir <- file.path(home,'phyloscanner_dated')#
	infiles <- data.table(F_PHSC=list.files(indir, pattern='collapsed_workspace.rda$', full.names=TRUE, recursive=TRUE))#
	infiles[, BASENAME:= gsub('collapsed_workspace.rda$','',basename(F_PHSC))]#
	tmp <- data.table(F_TREE=list.files(indir, pattern='collapsed_dated.newick$', full.names=TRUE, recursive=TRUE))#
	tmp[, BASENAME:= gsub('collapsed_dated.newick$','',basename(F_TREE))]#
	infiles <- merge(infiles, tmp, by='BASENAME', all.x=TRUE)	#
	infiles <- subset(infiles, is.na(F_TREE))
infiles
alignment.length <- 1000#
	##
	#	for each tree: #
	#	make data.table of sequence sampling times #
	#	remove taxa without data on sampling times#
	##
	cmds <- vector('list',nrow(infiles.phsc))#
	for(i in seq_len(nrow(infiles.phsc)))#
	{#
		#	i<- 1#
		cat('\nProcess',i)#
		outfile.collapsed.phsc <- infiles.phsc[i,F_PHSC]#
		outfile.tree <- file.path(outdir, gsub('collapsed_workspace\\.rda','collapsed\\.newick',basename(outfile.collapsed.phsc)) )#
		outfile.sampling.times.bounds <- file.path(outdir, gsub('collapsed_workspace\\.rda','sampling_times_bounds\\.csv',basename(outfile.collapsed.phsc)))#
		outfile.sampling.times.init <- file.path(outdir, gsub('collapsed_workspace\\.rda','sampling_times_init\\.csv',basename(outfile.collapsed.phsc)))#
		control <- list( outfile=gsub('.newick$','_dated.newick',outfile.tree), #
				ali.len=alignment.length, #
				root=NA, #
				omega0=NA, #
				temporalConstraints=TRUE, #
				strictClock=FALSE, #
				estimateSampleTimes=outfile.sampling.times.bounds #
		)#
		cmd <- cmd.treedater.script(outfile.tree, outfile.sampling.times.init, control=control)#
		cmds[[i]] <- cmd#
	}	#
	infiles.phsc[, CMD:= unlist(cmds)]	#
	#	submit jobs like this one:#
	cat(infiles.phsc[1,CMD])
cmds <- vector('list',nrow(infiles))#
	for(i in seq_len(nrow(infiles)))#
	{#
		#	i<- 1#
		cat('\nProcess',i)#
		outfile.collapsed.phsc <- infiles[i,F_PHSC]#
		outfile.tree <- file.path(outdir, gsub('collapsed_workspace\\.rda','collapsed\\.newick',basename(outfile.collapsed.phsc)) )#
		outfile.sampling.times.bounds <- file.path(outdir, gsub('collapsed_workspace\\.rda','sampling_times_bounds\\.csv',basename(outfile.collapsed.phsc)))#
		outfile.sampling.times.init <- file.path(outdir, gsub('collapsed_workspace\\.rda','sampling_times_init\\.csv',basename(outfile.collapsed.phsc)))#
		control <- list( outfile=gsub('.newick$','_dated.newick',outfile.tree), #
				ali.len=alignment.length, #
				root=NA, #
				omega0=NA, #
				temporalConstraints=TRUE, #
				strictClock=FALSE, #
				estimateSampleTimes=outfile.sampling.times.bounds #
		)#
		cmd <- cmd.treedater.script(outfile.tree, outfile.sampling.times.init, control=control)#
		cmds[[i]] <- cmd#
	}	#
	infiles[, CMD:= unlist(cmds)]
cat(infiles[1,CMD])
require(data.table)	#
	require(phyloscannerR)#
	home <- '~/Box Sync/OR_Work/Seattle/analysis_191017'#
	#home <- '/rds/general/project/ratmann_seattle_data_analysis/live/olli_191017'		#
	indir <- file.path(home,'phyloscanner_dated')#
	infiles <- data.table(F_PHSC=list.files(indir, pattern='collapsed_workspace.rda$', full.names=TRUE, recursive=TRUE))#
	infiles[, BASENAME:= gsub('collapsed_workspace.rda$','',basename(F_PHSC))]#
	tmp <- data.table(F_TREE=list.files(indir, pattern='collapsed_dated.newick$', full.names=TRUE, recursive=TRUE))#
	tmp[, BASENAME:= gsub('collapsed_dated.newick$','',basename(F_TREE))]#
	infiles <- merge(infiles, tmp, by='BASENAME', all.x=TRUE)	#
	subset(infiles, grepl('180709_LANL_SubtypeBc11_mafft_ndrm_008_ft_rerooted_KCHSX', F_TREE))
infiles <- subset(infiles, grepl('180709_LANL_SubtypeBc11_mafft_ndrm_008_ft_rerooted_KCHSX', F_TREE))
i<- 1
i<- 1#
		cat('\nProcess ',infiles[i,F_TREE])#
		#	load data#
		load(infiles[i,F_PHSC])#
		ph.dated <- read.tree(infiles[i,F_TREE])		#
		stopifnot( all(  ph.dated$tip.label == ph$tip.label ) )#
		stopifnot( all( ph.dated$edge == ph$edge ) )
ph
ph.dated
is.binary(ph)
require(big.phylo)#
	require(data.table)#
	require(tidyverse)#
	require(ape)#
	require(phytools)#
	require(treedater)#
	require(phyloscannerR)#
	home <- '~/Box Sync/OR_Work/Seattle/analysis_191017'#
	home <- '/rds/general/project/ratmann_seattle_data_analysis/live/olli_191017'#
	infile.seqinfo <- file.path(dirname(home),'PHSKC-2018-07-09','sequences_meta.rds')	#
	indir.phsc	<- file.path(home,'phyloscanner')#
	outdir <- file.path(home,'phyloscanner_dated')#
	infiles.phsc <- data.table(F=list.files(indir.phsc, pattern='workspace.rda$', full.names=TRUE, recursive=TRUE))#
	#infiles.phsc <- subset(infiles.phsc, grepl('000',F))#
	alignment.length <- 1000
subset(infiles.phsc, grepl('180709_LANL_SubtypeBc11_mafft_ndrm_008_ft_rerooted_KCHSX', F_TREE))
subset(infiles.phsc, grepl('180709_LANL_SubtypeBc11_mafft_ndrm_008_ft_rerooted_KCHSX', F))
infiles.phsc
home <- '~/Box Sync/OR_Work/Seattle/analysis_191017'
infile.seqinfo <- file.path(dirname(home),'PHSKC-2018-07-09','sequences_meta.rds')	#
	indir.phsc	<- file.path(home,'phyloscanner')#
	outdir <- file.path(home,'phyloscanner_dated')#
	infiles.phsc <- data.table(F=list.files(indir.phsc, pattern='workspace.rda$', full.names=TRUE, recursive=TRUE))#
	#infiles.phsc <- subset(infiles.phsc, grepl('000',F))#
	alignment.length <- 1000#
	infiles.phsc <- subset(infiles.phsc, grepl('180709_LANL_SubtypeBc11_mafft_ndrm_008_ft_rerooted_KCHSX', F))
infiles.phsc
dseq <- readRDS(infile.seqinfo) #
	dseq <- dseq %>% #
			select(seqID, newnum, type, seqy, seqm) %>%#
			mutate( SEQ_DATE:= seqy + (seqm-1)/12 + 15/365,#
					SEQ_DATE_LOWER:= seqy + (seqm-1)/12,#
					SEQ_DATE_UPPER:= seqy + (seqm-1)/12 + 30/365#
					) %>%#
			select(-seqy, -seqm) %>%#
			rename(TAXA= seqID, PID= newnum, TYPE=type)#
	dseq <- as.data.table(dseq)#
	##
	#	for each tree: #
	#	make data.table of sequence sampling times #
	#	remove taxa without data on sampling times#
	##
	cmds <- vector('list',nrow(infiles.phsc))
