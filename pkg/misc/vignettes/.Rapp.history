infiles <- subset(infiles, grepl('SubtypeBc[0-9]+',ST))
infiles
infiles <- data.table(FIN=list.files(outdir, pattern='\\.newick$',full.names=TRUE))#
	infiles[, ST:= gsub('^.*_Subtype([A-Za-z0-9]+)_.*$','\\1',basename(FIN))]
infiles[, table(ST)]
infiles <- subset(infiles, grepl('Bc[0-9]+',ST))
infiles
infiles <- data.table(FIN=list.files(outdir, pattern='\\.newick$',full.names=TRUE))#
	infiles[, ST:= gsub('^.*_Subtype([A-Za-z0-9]+)_.*$','\\1',basename(FIN))]	#
	infiles <- subset(infiles, grepl('Bc[0-9]+',ST))#
	cmds <- vector('list',nrow(infiles))	#
	for(i in seq_len(nrow(infiles)))#
	{				#
		# 	make phyloscanner UNIX command#
		infile <- infiles[i,FIN]#
		outputString <- paste0(gsub('\\.newick','_',infile))#
		tip.regex <- "^([A-Za-z]+)___.*$"#
		cmd <- paste("CWD=$(pwd)\n",sep='')#
		cmd <- paste(cmd,"echo $CWD\n",sep='')	#
		tmpdir.prefix <- paste('phsc_',format(Sys.time(),"%y-%m-%d-%H-%M-%S"),sep='')#
		tmpdir <- paste("$CWD/",tmpdir.prefix,sep='')#
		tmp.in <- file.path(tmpdir, basename(infile))#
		cmd <- paste(cmd,"mkdir -p ",tmpdir,'\n',sep='')#
		cmd <- paste(cmd,'cp "',infile,'" ',tmp.in,'\n', sep='')#
		cmd <- paste(cmd,'cd ', tmpdir,'\n', sep='')#
		cmd <- paste0(cmd,'Rscript ',prog.phyloscanner_analyse_trees,' ',basename(infile),' ',basename(outputString))	#
		cmd <- paste0(cmd,' s,0 -m 1e-5 -x "',tip.regex,'" -v 1 -ow -rda\n')#
		cmd <- paste0(cmd,'mv ',basename(outputString),'* ','"',dirname(outputString),'"','\n')	#
		cmd <- paste(cmd, "cd $CWD\n",sep='')#
		cmd <- paste(cmd, "rm ", tmpdir,'\n',sep='')#
		cmds[[i]] <- cmd#
	}#
	infiles[, CMD:= unlist(cmds)]	#
	#	submit jobs like this one:#
	cat(infiles[1,CMD])
96/8
require(data.table)#
	require(tidyverse)#
	require(ape)#
	require(phytools)#
	require(treedater)#
	home <- '~/Box Sync/OR_Work/Seattle'#
	infile.seqinfo <- file.path(home,'PHSKC-2018-07-09','sequences_meta.rds')	#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	infiles.phsc <- data.table(F=list.files(indir.phsc, pattern='workspace.rda$', full.names=TRUE, recursive=TRUE))
infiles.phsc
alignment.length <- 1000#
	##
	# read Seattle sampling data #
	##
	dseq <- readRDS(infile.seqinfo) #
	dseq <- dseq %>% #
			select(seqID, newnum, type, seqy, seqm) %>%#
			mutate( SEQ_DATE:= seqy + (seqm-1)/12 + 15/365,#
					SEQ_DATE_LOWER:= seqy + (seqm-1)/12,#
					SEQ_DATE_UPPER:= seqy + (seqm-1)/12 + 30/365#
					) %>%#
			select(-seqy, -seqm) %>%#
			rename(TAXA= seqID, PID= newnum, TYPE=type)#
	dseq <- as.data.table(dseq)
dseq
subset(infiles.phsc, grepl('000',F))
infiles.phsc <- subset(infiles.phsc, grepl('000',F))
alignment.length <- 1000#
	##
	# read Seattle sampling data #
	##
	dseq <- readRDS(infile.seqinfo) #
	dseq <- dseq %>% #
			select(seqID, newnum, type, seqy, seqm) %>%#
			mutate( SEQ_DATE:= seqy + (seqm-1)/12 + 15/365,#
					SEQ_DATE_LOWER:= seqy + (seqm-1)/12,#
					SEQ_DATE_UPPER:= seqy + (seqm-1)/12 + 30/365#
					) %>%#
			select(-seqy, -seqm) %>%#
			rename(TAXA= seqID, PID= newnum, TYPE=type)#
	dseq <- as.data.table(dseq)
i<- 1
infile <- infiles.phsc[i,F]	#
		load(infile)#
		ph <- phyloscanner.trees[[1]][['tree']]#
		stopifnot( !any( ph$tip.label=='' ) )#
		##
		#	drop tips without sequence dates, #
		#	while conserving the ancestral state reconstructions#
		##
		#	extract taxa names#
		dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		#	add Seattle sequence dates#
		dph <- merge(dph, dseq, by='TAXA', all.x=TRUE)#
		#	extract GenBank sequence dates from taxa names where possible #
		dph[, GENBANK_ID:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\5',TAXA)]#
		dph[, GENBANK_SEQDATE:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\3',TAXA)]#
		set(dph, dph[, which(GENBANK_SEQDATE=='-' | !is.na(SEQ_DATE))],'GENBANK_SEQDATE',NA_character_)	#
		set(dph, NULL, 'GENBANK_SEQDATE_LOWER', dph[, as.numeric(GENBANK_SEQDATE) ])#
		set(dph, NULL, 'GENBANK_SEQDATE_UPPER', dph[, as.numeric(GENBANK_SEQDATE) + 364/365 ])	#
		set(dph, NULL, 'GENBANK_SEQDATE', dph[, as.numeric(GENBANK_SEQDATE) + 1/2 ])#
		tmp <- dph[, which(is.na(SEQ_DATE))]#
		set(dph, tmp, 'SEQ_DATE', dph[tmp, GENBANK_SEQDATE])#
		set(dph, tmp, 'SEQ_DATE_LOWER', dph[tmp, GENBANK_SEQDATE_LOWER])#
		set(dph, tmp, 'SEQ_DATE_UPPER', dph[tmp, GENBANK_SEQDATE_UPPER])#
		set(dph, NULL, c('GENBANK_SEQDATE','GENBANK_SEQDATE_LOWER','GENBANK_SEQDATE_UPPER'), NULL)	#
		#	drop tips #
		dph.old <- subset(dph, select=c(TAXA, SEQ_DATE, SEQ_DATE_LOWER, SEQ_DATE_UPPER))	#
		tmp <- subset(dph, is.na(SEQ_DATE))[, TAXA_ID]#
		cat('Dropping tips without sampling date from ', infile,' n=', length(tmp), 'of Ntips=', Ntip(ph), '\n')
phyloscanner.to.simmap(ph)
# Get the tip number of this label#
#
#' @keywords internal#
#' @export get.tip.no#
#
get.tip.no <- function(tree, name) {#
  return(match(name, tree$tip.label))#
}#
#
# Get all tips associated with a host#
#
#' @keywords internal#
#' @export get.tips.for.host#
#
get.tips.for.host <- function(tree, host.string, host.ids, blacklist) {#
  node.numbers <- which(grepl(paste0('^',host.string),host.ids))#
  node.numbers <-#
    node.numbers[which(!(node.numbers %in% blacklist))]#
  return(node.numbers)#
}#
#
#' @keywords internal#
#' @export get.tips.for.sample#
#
get.tips.for.sample <- function(tree, sample.string){#
  return(which(grepl(paste0('^',sample.string),tree$tip.label)))#
}#
#
# Edge length by node number (probably in some library somewhere)#
#
#' @keywords internal#
#' @export get.edge.length#
#
get.edge.length <- function(tree, node) {#
  index <- which(tree$edge[,2] == node)#
  return(tree$edge.length[index])#
}#
#
# Node is a tip (likewise)#
#
#' @keywords internal#
#' @export is.tip#
#
is.tip <- function(tree, node) {#
  return(node <= length(tree$tip.label))#
}#
#
# Node is root (likewise)#
#
#' @keywords internal#
#' @export is.root#
#
is.root <- function(tree, node) {#
  return(Ancestors(tree, node, type = "parent") == 0)#
}#
#
# Get the sequence of ancestors from one node to the other#
#
#' @keywords internal#
#' @export get.ancestral.sequence#
#
get.ancestral.sequence <- function(tree, desc, anc) {#
  if (!(anc %in% Ancestors(tree, desc, type = "all"))) {#
    stop("anc is not an ancestor of desc at all")#
  }#
  current <- desc#
  out <- desc#
  while (current != anc) {#
    current <- Ancestors(tree, current, type = "parent")#
    out <- c(out, current)#
  }#
  return(out)#
}#
#
# Output the host that this tip belongs to. The vector host.ids #
# records hosts in the same order as the tips in the tree#
#
#' @keywords internal#
#' @export get.host.from.tip#
#
get.host.from.tip <- function(tree, node, host.ids) {#
  # is it a tip?#
  if (!(is.tip(tree, node))) {#
    stop("Not a tip")#
  }#
  host.id <- host.ids[node]#
  return(host.id)#
}#
#
# Output the set of hosts whose tips are descended from a node #
# (or the host of the node itself if a tip)#
#
#' @keywords internal#
#' @export get.hosts.from.this.clade#
#
get.hosts.from.this.clade <- function(tree, node, host.ids) {#
  if (is.tip(tree,node)) {#
    return(get.host.from.tip(tree, node, host.ids))#
  }#
  out <- vector()#
  tips <- Descendants(tree, node, type = "tips")[[1]]#
  for (tip in tips) {#
    if (!(get.host.from.tip(tree,tip) %in% out)) {#
      out <- c(out, get.host.from.tip(tree, tip, host.ids))#
    }#
  }#
  return(out)#
}#
#
# Is desc _unambiguously_ a descendant of anc? I.e. is the MRCA node of desc #
# a descendant of the MRCA node of anc, but no tips of anc are descended from#
# the MRCA node of desc?#
# mrca.list is a list of MRCA nodes indexed by host#
# tip.list is a list of vectors of tips indexed by host#
#
#' @keywords internal#
#' @export is.descendant.of#
#
is.descendant.of <- function(tree, desc, anc, mrca.list, tip.list) {#
  mrca.desc <- mrca.list[[desc]]#
  mrca.anc <- mrca.list[[anc]]#
  if (!(mrca.anc %in% Ancestors(tree, mrca.desc, type = "all"))) {#
    return(FALSE)#
  } else {#
    for (tip in tip.list[[anc]]) {#
      if (mrca.desc %in% Ancestors(tree, tip, type = "all")) {#
        return(FALSE)#
      }#
    }#
  }#
  return(TRUE)#
}#
#
# Is the intersection between vectors x and y empty?#
#
#' @keywords internal#
#' @export nonempty.intersection#
#
nonempty.intersection <- function(x,y) {#
  return(length(intersect(x,y)) > 0)#
}#
#
# Returns whether the tips corresponding to hosts pat.1 and pat.2 are intermingled#
# in tree, i.e. if the MRCA of one set is both descended from (or equal to) the MRCA of #
# the other and an ancestor of at least one tip from the other#
# mrca.list is a list of MRCA nodes indexed by host#
# tip.list is a list of vectors of tips indexed by host#
#
#' @keywords internal#
#' @export are.intermingled#
#
are.intermingled <-#
  function(tree, pat.1, pat.2, mrca.list, tip.list) {#
    mrca.1 <- mrca.list[[pat.1]]#
    mrca.2 <- mrca.list[[pat.2]]#
    if (mrca.1 == mrca.2) {#
      return(TRUE)#
    }#
    if ((mrca.1 %in% Ancestors(tree, mrca.2, type = "all"))) {#
      for (tip in tip.list[[pat.1]]) {#
        if (mrca.2 %in% Ancestors(tree, tip, type = "all")) {#
          return(TRUE)#
        }#
      }#
    }#
    if ((mrca.2 %in% Ancestors(tree, mrca.1, type = "all"))) {#
      for (tip in tip.list[[pat.2]]) {#
        if (mrca.1 %in% Ancestors(tree, tip, type = "all")) {#
          return(TRUE)#
        }#
      }#
    }#
    return(FALSE)#
  }#
#
# Output the set of hosts whose mrca is this node#
#
#' @keywords internal#
#' @export get.hosts.with.these.mrcas#
#
get.hosts.with.these.mrcas <-#
  function(tree, node, host.mrcas) {#
    out <- vector()#
    mrca.vec <- sapply(host.mrcas, "[[", 1)#
    numbers <- which(mrca.vec == node)#
    return(names(numbers))#
  }#
#
# Get the distance between the MRCA nodes of these two hosts#
#
#' @keywords internal#
#' @export get.mrca.distance#
#
get.mrca.distance <- function(tree, pat.1, pat.2, mrca.list) {#
  mrca.1 <- mrca.list[[pat.1]]#
  mrca.2 <- mrca.list[[pat.2]]#
  return(total.length.between(tree, mrca.1, mrca.2))#
}#
#
# Get the distance between these two nodes#
#
#' @keywords internal#
#' @export total.length.between#
#
total.length.between <- function(tree, node.1, node.2) {#
  if (node.1 == node.2) {#
    return(0)#
  }#
  total.length <- 0#
  if (node.1 %in% Descendants(tree, node.2, type = "all")) {#
    current.node <- node.1#
    while (current.node != node.2) {#
      total.length <- total.length + get.edge.length(tree, current.node)#
      current.node <- Ancestors(tree, current.node, type = "parent")#
    }#
    return(total.length)#
  } else if (node.2 %in% Descendants(tree, node.1, type = "all")) {#
    current.node <- node.2#
    while (current.node != node.1) {#
      total.length <- total.length + get.edge.length(tree, current.node)#
      current.node <- Ancestors(tree, current.node, type = "parent")#
    }#
    return(total.length)#
  } else {#
    joint.mrca <- mrca.phylo(tree, c(node.1, node.2))#
    return(#
      total.length.between(tree, node.1, joint.mrca) + total.length.between(tree, node.2, joint.mrca)#
    )#
  }#
}#
#
# mrca.phylo applied to a tip only will not return that tip. This function will.#
#
#' @keywords internal#
#' @export mrca.phylo.or.unique.tip#
#
mrca.phylo.or.unique.tip <-#
  function(tree, node, zero.length.tips.count = FALSE) {#
    if (length(node) == 1) {#
      if (!zero.length.tips.count | !is.tip(tree,node)) {#
        return(node)#
      } else {#
        length <- get.edge.length(tree, node)#
        while (length < 1E-5) {#
          node <- Ancestors(tree, node, type = "parent")#
          if (is.root(tree, node)) {#
            break#
          }#
          length <- get.edge.length(tree, node)#
        }#
        return(node)#
      }#
    } else {#
      mrca <- mrca.phylo(tree, node)#
      return(mrca)#
    }#
  }#
#
# This function returns TRUE wherever elements are the same, including NA's, and false #
# everywhere else.#
#
#' @keywords internal#
#' @export compareNA#
#
compareNA <- function(v1,v2) {#
  same <- (v1 == v2)  |  (is.na(v1) & is.na(v2))#
  same[is.na(same)] <- FALSE#
  return(same)#
}#
#
# Last element in a vector#
#
#' @keywords internal#
#' @export get.last#
#
get.last <- function(vec)#
  return(vec[length(vec)])#
#
# Get host id from tip label#
#
#' @keywords internal#
#' @export host.from.label#
#
host.from.label <- function(label, regexp){#
  if(length(grep(regexp, label)>0)) {#
    return(sub(regexp, "\\1", label))#
  } else {#
    return(NA)#
  }#
}#
#
# Get read count from label#
#
#' @keywords internal#
#' @export read.count.from.label#
#
read.count.from.label <- function(label, regexp){#
  if(length(grep(regexp, label)>0)) {#
    return(as.integer(sub(regexp, "\\3", label)))#
  } else {#
    return(NA)#
  }#
}#
#
# Starting at node 1, determine whether the path to node 2 is blocked by node 3#
# Should work on both rooted and unrooted trees I _hope_.#
#
#' @keywords internal#
#' @export path.exists#
#
path.exists <- function(tree, node.1, node.2, node.3, last.node = -1){#
  #  cat(node.1," ")#
  if(node.1 == node.2){#
    return(TRUE)#
  }#
  if(node.1 == node.3){#
    return(FALSE)#
  }#
  neighbours = vector()#
  if(!is.tip(tree, node.1)){#
    neighbours <- Children(tree, node.1)#
  }#
  if(length(Ancestors(tree, node.1, type="parent"))!=0){#
    if(Ancestors(tree, node.1, type="parent")!=0){#
      neighbours <- c(neighbours, Ancestors(tree, node.1, type="parent"))#
    }#
  }#
  for(neighbour in neighbours){#
    if(neighbour != last.node){#
      if(path.exists(tree, neighbour, node.2, node.3, node.1)){#
        return(TRUE)#
        break#
      }#
    }#
  }#
  #you've been everywhere and you can't find a way through#
  return(FALSE)#
}#
#
#' @keywords internal#
#' @export tips.reachable#
#
tips.reachable <- function(tree, node, blocking.edges, last.node = -1){#
  out <- vector()#
  if(is.tip(tree, node)){#
    out <- c(out, node)#
  }#
  neighbours = neighbouring.nodes(tree, node)#
  for(neighbour in neighbours){#
    if(neighbour != last.node){#
      edge.vec <- c(node, neighbour)#
      if(is.na(row.match(edge.vec, t(as.matrix(blocking.edges)))) &  is.na(row.match(rev(edge.vec), t(as.matrix(blocking.edges))))){#
        out <- c(out, tips.reachable(tree, neighbour, blocking.edges, node))#
      }#
    }#
  }#
  return(out)#
}#
#
#' @keywords internal#
#' @export neighbouring.nodes#
#
neighbouring.nodes <- function(tree, node){#
  part.1 <- tree$edge[which(tree$edge[,2]==node), 1]#
  part.2 <- tree$edge[which(tree$edge[,1]==node), 2]#
  return(c(part.1, part.2))#
}#
# Drop a set of tips and return a vector which maps nodes from the full tree to the subtree#
#
#' @keywords internal#
#' @export drop.tip.get.map#
#
drop.tip.get.map <- function(phy, tip){#
  if(length(unique(tree$tip.label))!=length(tree$tip.label)){#
    stop("This won't work if there are duplicate tip names")#
  }#
  reference <- vector()#
  phy.2 <- drop.tip(phy, tip)#
  for(new.label in seq(1, length(phy.2$tip.label))){#
    reference[new.label] = which(phy$tip.label==phy.2$tip.label[new.label])#
  }#
  mrcas.1 <- mrca(phy)#
  mrcas.2 <- mrca(phy.2)#
  for(tip.1 in seq(1, length(phy.2$tip.label))){#
    for(tip.2 in seq(1, length(phy.2$tip.label))){#
      if(tip.1 < tip.2){#
        new.mrca <- mrcas.2[tip.1,tip.2]#
        old.mrca <- mrcas.1[reference[tip.1], reference[tip.2]]#
        reference[new.mrca] = old.mrca#
      }#
    }#
  }#
  return(list(tree = phy.2, reference=reference))#
}#
#
#' @keywords internal#
#' @export extract.subtrees.for.hosts#
#
extract.subtrees.for.hosts <- function(tree, hosts, splits){#
  labels.to.keep <- splits$tip.names[which(splits$orig.hosts %in% hosts)]#
  pruned.tree <- drop.tip(tree, which(!(tree$tip.label %in% labels.to.keep)))#
  return(pruned.tree)#
}#
#
#' @keywords internal#
#' @export prop.internal.longer.than.root#
#
prop.internal.longer.than.root <- function(tree, split, splits){#
  tips <- splits$tip.names[which(splits$host.splits==split)]#
  if(length(tips)==1){#
    return(0)#
  }#
  split.root <- mrca.phylo.or.unique.tip(tree, which(tree$tip.label %in% tips))#
  dist.to.root <- 0 #
  current.node <- split.root#
  while(!is.root(tree, current.node)){#
    dist.to.root <- dist.to.root + get.edge.length(tree, split.root)#
    current.node <- Ancestors(tree, current.node, type="parent")#
  }#
  just.clade <- drop.tip(tree, which(!(tree$tip.label %in% tips)))#
  edges <- just.clade$edge.length#
  return(sum(edges > dist.to.root)/length(edges))#
}#
#
#' @keywords internal#
#' @export process.tree#
#' @importFrom ape di2multi root#
#
process.tree <- function(tree, root.name=NULL, m.thresh=-1, blacklist.for.pruning = vector(), normalisation.constant = 1) {#
  if(m.thresh != -1){#
    tree <- di2multi(tree, tol = m.thresh)#
  }#
  if(!is.null(root.name)){#
    tree <- root(tree, outgroup = root.name, resolve.root = T)#
  } else {#
    # There are problems with a non-binary root.  Resolve it arbitrarily; most times a root should be specified.#
    if(length(Children(tree, getRoot(tree)))>2){#
      first.child <- Children(tree, getRoot(tree))[1]#
      if(first.child <= length(tree$tip.label)){#
        tree <- root(tree, outgroup=first.child, resolve.root = T)#
      } else {#
        tree <- root(tree, node=first.child, resolve.root = T)#
      }#
    }#
  }#
  if(length(blacklist.for.pruning) > 0){#
    tree <- drop.tip(tree, blacklist.for.pruning)#
  }#
  tree$edge.length <- tree$edge.length/normalisation.constant#
  return(tree)#
}#
#
#' @title Select for further analysis relationship classifications by read and tip counts #
#' @export select.windows.by.read.and.tip.count#
#' @import tidyverse #
#' @author Oliver Ratmann, Matthew Hall#
#' @param ptrees A list of class \code{phyloscanner.trees} produced by \code{phyloscanner.analyse.trees}.#
#' @param dwin A data frame produced by \code{classify.pairwise.relationships}.#
#' @param tip.regex The regular expression used to identify host IDs in tip names#
#' @param min.reads The minimum number of reads from a host in a window needed in order for that window to count in determining relationships involving that patient#
#' @param min.tips The minimum number of tips from a host in a window needed in order for that window to count in determining relationships involving that patient#
#' @param verbose Verbose output#
#' @return A data frame with viral phylogenetic classifications of pairwise host relationships in each deep sequence phylogeny#
#' @examples#
#' \dontrun{#
#' require(phyloscannerR)#
#' ##
#' #	continue Rakai example,#
#' #	load phyloscanner output from 'phyloscanner.analyse.trees'#
#' #	#
#' file	<- system.file(file.path('extdata','ptyr192_phsc_analyse_trees_output.R'),package='phyloscannerR')#
#' load(file)	#loads 'phsc', output from 'phyloscanner.analyse.trees'#
#' #	use distance thresholds found in analysis of Rakai couples#
#' close.threshold <- 0.025#
#' distant.threshold <- 0.05	#
#' #	use relationship types based on adjacency#
#' #	this also considers linkage etc between individuals who have dual infections, recombinants etc #
#' #	..and thus may not have *all* their subgraphs adjacent to each other#
#' relationship.types <- c('proximity.3.way',					#
#' 		'close.and.adjacent',					#
#' 		'close.and.adjacent.and.directed',					#
#' 		'close.and.adjacent.and.ancestry.cat')	#
#' dwin <- classify.pairwise.relationships(phsc, allow.mt=TRUE, close.threshold=close.threshold, distant.threshold=distant.threshold,relationship.types=relationship.types, verbose=TRUE)#
#' tip.regex <- "^(.*)_fq[0-9]+_read_([0-9]+)_count_([0-9]+)$"#
#' min.reads <- 30#
#' min.tips <- 1#
#' dwin <- select.windows.by.read.and.tip.count(phsc, dwin, tip.regex, min.reads, min.tips)#
#' ##
#' # 	end of Rakai example#
#' ##
#' }	 	#
select.windows.by.read.and.tip.count <- function(ptrees, dwin, tip.regex, min.reads, min.tips, verbose=F)			#
{#
  host.tips.and.reads <- map(ptrees, function(x) phyloscannerR:::get.tip.and.read.counts(x, all.hosts.from.trees(ptrees), tip.regex, attr(ptrees, 'has.read.counts'), verbose = F))#
  host.tips.and.reads <- bind_rows(host.tips.and.reads)#
  if(verbose) cat('Merging tip and read counts...\n')#
  dwin <- dwin %>% #
    inner_join(host.tips.and.reads, by=c("host.1"="host.id", "tree.id")) %>% #
    rename(tips.1 = tips, reads.1=reads)#
  dwin <- dwin %>% #
    inner_join(host.tips.and.reads, by=c("host.2"="host.id", "tree.id")) %>% #
    rename(tips.2 = tips, reads.2=reads)	#
  if(verbose) cat('Reducing transmission window stats to windows with at least',min.reads,'reads and at least',min.tips,'tips...\n')#
  dwin	<- dwin %>% #
    filter(reads.1 >= min.reads & reads.2 >= min.reads & tips.1 >= min.tips & tips.2 >= min.tips)#
  if(verbose) cat('Total number of windows with transmission assignments is ',nrow(dwin),'.\n', sep="")		#
  dwin#
}#
#
#' @title Cast phyloscanner tree to SIMMAP tree#
#' @export phyloscanner.to.simmap#
#' @author Oliver Ratmann#
#' @importFrom reshape2 dcast#
#' @usage phyloscanner.to.simmap(ph, delete.phyloscanner.structures)#
#' @param ph A \code{phyloscanner.tree} with attributes \code{SPLIT}, \code{INDIVIDUAL}, \code{BRANCH_COLOURS}, \code{SUBGRAPH_MRCA}.#
#' @param delete.phyloscanner.structures Logical value. If true \code{phyloscanner} attributes are removed from the tree.#
#' @return Same tree in \code{SIMMAP} format, with elements \code{maps}, \code{mapped.edge}, \code{node.states}.#
#' @seealso \code{\link{simmap.to.phyloscanner}}, \code{\link{extract.subgraph}}#
#' @example inst/example/ex.cast.to.simmap.R#
phyloscanner.to.simmap<- function(ph, delete.phyloscanner.structures=FALSE)#
{#
	# make maps for each edge#
	# attr(ph, 'SPLIT') specifies state of branch ending in node #
	edge.state <- as.character( attr(ph, 'SPLIT')[ ph$edge[,2] ] )#
	edge.state[is.na(edge.state)] <- 'Unknown'	#
	edge.maps <- ph$edge.length	#
	# make mapped.edge matrix#
	mapped.edge <- data.frame(STATE= edge.state, LEN=edge.maps, IDX=seq_along(edge.state))#
	mapped.edge <- reshape2:::dcast(mapped.edge, IDX~STATE, value.var='LEN')#
	for(x in colnames(mapped.edge))#
		mapped.edge[[x]][ which(is.na(mapped.edge[[x]])) ] <- 0#
	mapped.edge <- as.matrix(mapped.edge)	#
	rownames(mapped.edge) <- apply(ph$edge,1,paste, collapse=',')	#
	# finalise edge.maps#
	edge.maps <- lapply(seq_along(edge.maps), function(k){ x<- edge.maps[[k]]; names(x)<- edge.state[k]; x})#
	# make node.states	#
	node.states <- as.character( attr(ph, 'SPLIT')[ ph$edge[,1] ] )#
	node.states[is.na(node.states)] <- 'Unknown'#
	node.states <- matrix(node.states, nrow=nrow(ph$edge), ncol=2)	#
	node.states[,2] <- edge.state#
	# set list elements#
	ph[['maps']] <- edge.maps#
	ph[['mapped.edge']] <- mapped.edge#
	ph[['node.states']] <- node.states#
	# set attributes#
	attr(ph,'class') <- c("simmap", "phylo")#
	attr(ph, "map.order") <- "right-to-left"#
	attr(ph, "order") <- "cladewise"#
	# delete attributes#
	if(delete.phyloscanner.structures)#
	{#
		attr(ph, "SPLIT") <- NULL#
		attr(ph, "INDIVIDUAL") <- NULL#
		attr(ph, "BRANCH_COLOURS") <- NULL#
		attr(ph, "SUBGRAPH_MRCA") <- NULL	#
	}	#
	ph#
}#
#
#' @title Cast SIMMAP tree to phyloscanner tree#
#' @export simmap.to.phyloscanner#
#' @importFrom phangorn Ancestors#
#' @author Oliver Ratmann#
#' @usage simmap.to.phyloscanner(ph, delete.simmap.structures)#
#' @param ph A \code{SIMMAP} tree with elements \code{maps}, \code{mapped.edge}, \code{node.states}.#
#' @param delete.simmap.structures Logical value. If true \code{SIMMAP} elements are removed from the tree.#
#' @return Same tree in \code{phyloscanner.tree} format, with attributes \code{SPLIT}, \code{INDIVIDUAL}, \code{BRANCH_COLOURS}, \code{SUBGRAPH_MRCA}.#
#' @seealso \code{\link{phyloscanner.to.simmap}}, \code{\link{extract.subgraph}}#
#' @example inst/example/ex.cast.to.simmap.R#
simmap.to.phyloscanner <- function(ph, delete.simmap.structures=FALSE)#
{#
	stopifnot( any(class(ph)=='simmap') )#
	# state at each node. set root to Unknown by default#
	node.states <- vector('character', Nnode(ph, internal.only=FALSE))#
	node.states[ph$edge[,2]] <- ph$node.states[,2]#
	node.states[Ntip(ph)+1] <- 'Unknown'#
	# find subgraph mrcas#
	subgraphs <- setdiff(sort(unique(node.states)),'Unknown') #
	# for each subgraph, find one member node#
	subgraph.member <- sapply(subgraphs, function(x) which(node.states==x)[1] )#
	# for each member, descend in tree and find most ancestral member node, which is the mrca of the subgraph#
	subgraph.ancestors <- phangorn:::Ancestors(ph, subgraph.member)#
	subgraph.mrcas <- sapply(seq_along(subgraph.ancestors), function(j){				#
				subgraph.mrca <- subgraph.member[j]#
				subgraph.name <- names(subgraph.member)[j]#
				nodes.in.same.subgraph.idx <- which(node.states[subgraph.ancestors[[j]]]==subgraph.name)#
				if(length(nodes.in.same.subgraph.idx))#
					subgraph.mrca <- subgraph.ancestors[[j]][ tail(nodes.in.same.subgraph.idx,1) ]#
				subgraph.mrca#
			})#
	names(subgraph.mrcas) <- subgraphs#
	#	make phyloscanner attributes#
	attr(ph, 'SPLIT') <- node.states#
	tmp <- rep(FALSE, length(node.states))#
	tmp[subgraph.mrcas] <- TRUE#
	attr(ph, 'SUBGRAPH_MRCA') <- tmp#
	attr(ph, 'INDIVIDUAL') <- gsub('-SPLIT[0-9]+','',node.states)#
	tmp <- t( rbind( node.states[ ph$edge[,1] ], #
					node.states[ ph$edge[,2] ], #
					node.states[ ph$edge[,2] ] ) )#
	tmp[tmp[,1]!=tmp[,2], 3] <- 'Unknown'	#
	tmp <- gsub('-SPLIT[0-9]+','',tmp[,3])#
	attr(ph, 'BRANCH_COLOURS') <- rep(NA, Nnode(ph, internal.only=FALSE)) #
	attr(ph, 'BRANCH_COLOURS')[ ph$edge[,2] ] <- tmp		#
	attr(ph, 'SPLIT')[attr(ph, 'SPLIT')=='Unknown'] <- NA#
	attr(ph, 'INDIVIDUAL')[attr(ph, 'INDIVIDUAL')=='Unknown'] <- NA#
	attr(ph, 'BRANCH_COLOURS')[attr(ph, 'BRANCH_COLOURS')=='Unknown'] <- NA#
	attr(ph, 'SPLIT') <- factor(attr(ph, 'SPLIT'))#
	attr(ph, 'INDIVIDUAL') <- factor(attr(ph, 'INDIVIDUAL'))#
	attr(ph, 'BRANCH_COLOURS') <- factor(attr(ph, 'BRANCH_COLOURS'))#
	if(delete.simmap.structures)#
	{#
		ph[["maps"]] <- NULL#
		ph[["mapped.edge"]] <- NULL#
		ph[["node.states"]] <- NULL#
		attr(ph, 'map.order') <- NULL#
		attr(ph, 'class') <- 'phylo'		#
	}#
	ph#
}#
#
#' @title Extract subgraph from phyloscanner tree#
#' @export extract.subgraph#
#' @importFrom phangorn Ancestors#
#' @author Oliver Ratmann#
#' @usage extract.subgraph(ph, mrca)#
#' @param ph A tree of class \code{SIMMAP} and \code{phyloscanner}, i.e. with elements \code{maps}, \code{mapped.edge}, \code{node.states} and with attributes \code{SPLIT}, \code{INDIVIDUAL}, \code{BRANCH_COLOURS}, \code{SUBGRAPH_MRCA}.#
#' @param mrca Node index of subgraph MRCA#
#' @return Subgraph in ape format, with additional elements \code{subgraph.name} (subgraph name in the phyloscanner SPLIT attribute), \code{subgraph.root.edge} (length of the ancestral edge of the subgraph MRCA), \code{subgraph.parent.state} (ancestral state of the parent of subgraph MRCA).  #
#' @seealso \code{\link{phyloscanner.to.simmap}}#
#' @example inst/example/ex.extract.subgraph.R#
extract.subgraph<- function(ph, mrca)#
{#
	stopifnot( any(class(ph)=='simmap') )#
	stopifnot( c("SPLIT","INDIVIDUAL","BRANCH_COLOURS","SUBGRAPH_MRCA")%in%names(attributes(ph)) )#
	subgraph.name <- as.character(attr(ph, 'SPLIT')[mrca])#
	host <- as.character(attr(ph, "INDIVIDUAL")[mrca])#
	subgraph.root.edge <- ph$edge.length[ which( ph$edge[,2]==mrca ) ]#
	subgraph.parent.state <- as.character(attr(ph, "BRANCH_COLOURS")[ ph$edge[ph$edge[,2]==mrca,1] ])#
	stopifnot( is.na(subgraph.parent.state) || subgraph.parent.state!=host )#
	if(mrca<=Ntip(ph))#
	{#
		subgraph<- list(	edge= matrix(nrow=0, ncol=2), #
				edge.length=vector('numeric',0),#
				Nnode=0,#
				tip.label=ph$tip.label[mrca],#
				maps= vector('list',0),#
				mapped.edge= matrix(nrow=0, ncol=0),#
				node.states= matrix(nrow=0, ncol=2)#
		)#
		#attr(subgraph,'class') <- c( "phylo")#
		#attr(subgraph, "map.order") <- "right-to-left"#
		#attr(subgraph, "order") <- "cladewise"		#
	}#
	if(mrca>Ntip(ph))#
	{#
		subgraph <- phytools:::extract.clade.simmap(ph, mrca)#
		subgraph.root <- Ntip(subgraph)+1L#
		descendants <- Descendants(subgraph, subgraph.root, type='all')#
		tmp <- sapply(descendants, function(x) which(subgraph$edge[,2]==x))#
		descendants.states <- subgraph[['node.states']][tmp,2]#
		descendants.not.in.subgraph <- descendants[ descendants.states!=subgraph.name ]#
		if(length(descendants.not.in.subgraph))#
		{#
			# find all tips of descendants.not.in.subgraph, and remove the corresponding tips, which will remove the subtree for each descendant#
			tips.not.in.subgraph <- sort(unique(unlist(Descendants(subgraph, descendants.not.in.subgraph, type='tips'))))#
			subgraph <- ape:::drop.tip(subgraph, tips.not.in.subgraph)#
			subgraph[['maps']] <- NULL#
			subgraph[['mapped.edge']] <- NULL#
			subgraph[['node.states']] <- NULL#
			attr(subgraph,'class') <- c( "phylo")#
			attr(subgraph, "map.order") <- NULL#
			attr(subgraph, "order") <- NULL#
			attr(subgraph, "SPLIT") <- NULL#
			attr(subgraph, "INDIVIDUAL") <- NULL#
			attr(subgraph, "BRANCH_COLOURS") <- NULL#
			attr(subgraph, "SUBGRAPH_MRCA") <- NULL			#
		}		#
	}#
	subgraph[['subgraph.name']]<- subgraph.name#
	subgraph[['subgraph.root.edge']]<- subgraph.root.edge#
	subgraph[['subgraph.parent.state']]<- subgraph.parent.state#
	subgraph	#
}
phyloscanner.to.simmap(ph)
ph <- phyloscanner.to.simmap(ph)	#
		ph <- phytools:::drop.tip.simmap(ph, ph$tip.label[tmp])#
		ph <- simmap.to.phyloscanner(ph)
dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		dph <- merge(dph, dph.old, by= 'TAXA')#
		stopifnot( !any(is.na(dph$SEQ_DATE)) )#
		dph <- dph[order(TAXA_ID),]#
		#	get into format needed for tree.dater	#
		#sampling.times <- dph$SEQ_DATE#
		#names(sampling.times) <- dph$TAXA_LABEL	#
		sampling.times.init <- dph$SEQ_DATE#
		names(sampling.times.init) <- dph$TAXA_LABEL#
		sampling.times.bounds <- as.data.frame(subset(dph, select=c(SEQ_DATE_LOWER, SEQ_DATE_UPPER)))#
		rownames(sampling.times.bounds) <- dph$TAXA_LABEL		#
		colnames(sampling.times.bounds) <- c('lower','upper')
ph.dated <- dater(ph, sampling.times.init, alignment.length, numStartConditions=1, estimateSampleTimes=sampling.times.bounds )#
		stopifnot( all(  ph.dated$tip.label == ph$tip.label ) )#
		stopifnot( all( ph.dated$edge == ph$edge ) )
ph$edge.length <- ph.dated$edge.length#
		##
		#	plot dated tree to spot obvious errors#
		##
		outfile <- gsub('workspace\\.rda','annotated_dated_tree.pdf',infile)#
		tmp <- vector('list')#
		tmp[['tree']] <- ph#
		tmp[['tree']][['node.states']] <- tmp[['tree']][['mapped.edge']] <- tmp[['tree']][['maps']] <- NULL#
		attr(tmp[['tree']],'map.order') <- NULL#
		attr(tmp[['tree']],'class') <- 'phylo'#
		tmp[['read.counts']] <- rep(1, Ntip(ph))	#
		write.annotated.tree(tmp, outfile, format="pdf", pdf.scale.bar.width = 0.01, pdf.w = 40, pdf.hm = 0.2, verbose = FALSE)#
		##
		#	save phyloscanner.tree#
		##
		outfile <- gsub('workspace\\.rda','annotated_dated_tree.rda',infile)#
		save(ph, file=outfile)
require(phyloscannerR)
i<- 1
infile <- infiles.phsc[i,F]	#
		load(infile)#
		ph <- phyloscanner.trees[[1]][['tree']]#
		stopifnot( !any( ph$tip.label=='' ) )#
		##
		#	drop tips without sequence dates, #
		#	while conserving the ancestral state reconstructions#
		##
		#	extract taxa names#
		dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		#	add Seattle sequence dates#
		dph <- merge(dph, dseq, by='TAXA', all.x=TRUE)#
		#	extract GenBank sequence dates from taxa names where possible #
		dph[, GENBANK_ID:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\5',TAXA)]#
		dph[, GENBANK_SEQDATE:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\3',TAXA)]#
		set(dph, dph[, which(GENBANK_SEQDATE=='-' | !is.na(SEQ_DATE))],'GENBANK_SEQDATE',NA_character_)	#
		set(dph, NULL, 'GENBANK_SEQDATE_LOWER', dph[, as.numeric(GENBANK_SEQDATE) ])#
		set(dph, NULL, 'GENBANK_SEQDATE_UPPER', dph[, as.numeric(GENBANK_SEQDATE) + 364/365 ])	#
		set(dph, NULL, 'GENBANK_SEQDATE', dph[, as.numeric(GENBANK_SEQDATE) + 1/2 ])#
		tmp <- dph[, which(is.na(SEQ_DATE))]#
		set(dph, tmp, 'SEQ_DATE', dph[tmp, GENBANK_SEQDATE])#
		set(dph, tmp, 'SEQ_DATE_LOWER', dph[tmp, GENBANK_SEQDATE_LOWER])#
		set(dph, tmp, 'SEQ_DATE_UPPER', dph[tmp, GENBANK_SEQDATE_UPPER])#
		set(dph, NULL, c('GENBANK_SEQDATE','GENBANK_SEQDATE_LOWER','GENBANK_SEQDATE_UPPER'), NULL)	#
		#	drop tips #
		dph.old <- subset(dph, select=c(TAXA, SEQ_DATE, SEQ_DATE_LOWER, SEQ_DATE_UPPER))	#
		tmp <- subset(dph, is.na(SEQ_DATE))[, TAXA_ID]#
		cat('Dropping tips without sampling date from ', infile,' n=', length(tmp), 'of Ntips=', Ntip(ph), '\n')#
		ph <- phyloscanner.to.simmap(ph)	#
		ph <- phytools:::drop.tip.simmap(ph, ph$tip.label[tmp])#
		ph <- simmap.to.phyloscanner(ph)#
		##
		#	date tree#
		#	#
		#	make data.table of sequence sampling times#
		dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		dph <- merge(dph, dph.old, by= 'TAXA')#
		stopifnot( !any(is.na(dph$SEQ_DATE)) )#
		dph <- dph[order(TAXA_ID),]#
		#	get into format needed for tree.dater	#
		#sampling.times <- dph$SEQ_DATE#
		#names(sampling.times) <- dph$TAXA_LABEL	#
		sampling.times.init <- dph$SEQ_DATE#
		names(sampling.times.init) <- dph$TAXA_LABEL#
		sampling.times.bounds <- as.data.frame(subset(dph, select=c(SEQ_DATE_LOWER, SEQ_DATE_UPPER)))#
		rownames(sampling.times.bounds) <- dph$TAXA_LABEL		#
		colnames(sampling.times.bounds) <- c('lower','upper')#
		#	date tree#
		#ph.dated <- dater(ph, sampling.times, alignment.length, numStartConditions=1)#
		ph.dated <- dater(ph, sampling.times.init, alignment.length, numStartConditions=1, estimateSampleTimes=sampling.times.bounds )#
		stopifnot( all(  ph.dated$tip.label == ph$tip.label ) )#
		stopifnot( all( ph.dated$edge == ph$edge ) )#
		#	since the tree topology is unchanged, we can copy#
		#	the branch lenghts in units of time onto the original tree#
		#	that has the ancestral state reconstructions#
		ph$edge.length <- ph.dated$edge.length
outfile <- gsub('workspace\\.rda','annotated_dated_tree.pdf',infile)#
		tmp <- vector('list')#
		tmp[['tree']] <- ph#
		tmp[['tree']][['node.states']] <- tmp[['tree']][['mapped.edge']] <- tmp[['tree']][['maps']] <- NULL#
		attr(tmp[['tree']],'map.order') <- NULL#
		attr(tmp[['tree']],'class') <- 'phylo'#
		tmp[['read.counts']] <- rep(1, Ntip(ph))	#
		write.annotated.tree(tmp, outfile, format="pdf", pdf.scale.bar.width = 0.01, pdf.w = 40, pdf.hm = 0.2, verbose = FALSE)#
		##
		#	save phyloscanner.tree#
		##
		outfile <- gsub('workspace\\.rda','annotated_dated_tree.rda',infile)#
		save(ph, file=outfile)
for(i in seq_len(nrow(infiles.phsc)))#
	{#
		infile <- infiles.phsc[i,F]	#
		load(infile)#
		ph <- phyloscanner.trees[[1]][['tree']]#
		stopifnot( !any( ph$tip.label=='' ) )#
		##
		#	drop tips without sequence dates, #
		#	while conserving the ancestral state reconstructions#
		##
		#	extract taxa names#
		dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		#	add Seattle sequence dates#
		dph <- merge(dph, dseq, by='TAXA', all.x=TRUE)#
		#	extract GenBank sequence dates from taxa names where possible #
		dph[, GENBANK_ID:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\5',TAXA)]#
		dph[, GENBANK_SEQDATE:= gsub('^([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)\\.([^\\.]+)$','\\3',TAXA)]#
		set(dph, dph[, which(GENBANK_SEQDATE=='-' | !is.na(SEQ_DATE))],'GENBANK_SEQDATE',NA_character_)	#
		set(dph, NULL, 'GENBANK_SEQDATE_LOWER', dph[, as.numeric(GENBANK_SEQDATE) ])#
		set(dph, NULL, 'GENBANK_SEQDATE_UPPER', dph[, as.numeric(GENBANK_SEQDATE) + 364/365 ])	#
		set(dph, NULL, 'GENBANK_SEQDATE', dph[, as.numeric(GENBANK_SEQDATE) + 1/2 ])#
		tmp <- dph[, which(is.na(SEQ_DATE))]#
		set(dph, tmp, 'SEQ_DATE', dph[tmp, GENBANK_SEQDATE])#
		set(dph, tmp, 'SEQ_DATE_LOWER', dph[tmp, GENBANK_SEQDATE_LOWER])#
		set(dph, tmp, 'SEQ_DATE_UPPER', dph[tmp, GENBANK_SEQDATE_UPPER])#
		set(dph, NULL, c('GENBANK_SEQDATE','GENBANK_SEQDATE_LOWER','GENBANK_SEQDATE_UPPER'), NULL)	#
		#	drop tips #
		dph.old <- subset(dph, select=c(TAXA, SEQ_DATE, SEQ_DATE_LOWER, SEQ_DATE_UPPER))	#
		tmp <- subset(dph, is.na(SEQ_DATE))[, TAXA_ID]#
		cat('Dropping tips without sampling date from ', infile,' n=', length(tmp), 'of Ntips=', Ntip(ph), '\n')#
		ph <- phyloscanner.to.simmap(ph)	#
		ph <- phytools:::drop.tip.simmap(ph, ph$tip.label[tmp])#
		ph <- simmap.to.phyloscanner(ph)#
		##
		#	date tree#
		#	#
		#	make data.table of sequence sampling times#
		dph <- data.table(	TAXA_LABEL=ph$tip.label,#
				TAXA= gsub('^(PR/RT-[0-9]+).*','\\1',gsub('^[^_]+___(.*)','\\1',ph$tip.label)),#
				TAXA_ID= seq_along(ph$tip.label))#
		dph <- merge(dph, dph.old, by= 'TAXA')#
		stopifnot( !any(is.na(dph$SEQ_DATE)) )#
		dph <- dph[order(TAXA_ID),]#
		#	get into format needed for tree.dater	#
		#sampling.times <- dph$SEQ_DATE#
		#names(sampling.times) <- dph$TAXA_LABEL	#
		sampling.times.init <- dph$SEQ_DATE#
		names(sampling.times.init) <- dph$TAXA_LABEL#
		sampling.times.bounds <- as.data.frame(subset(dph, select=c(SEQ_DATE_LOWER, SEQ_DATE_UPPER)))#
		rownames(sampling.times.bounds) <- dph$TAXA_LABEL		#
		colnames(sampling.times.bounds) <- c('lower','upper')#
		#	date tree#
		#ph.dated <- dater(ph, sampling.times, alignment.length, numStartConditions=1)#
		ph.dated <- dater(ph, sampling.times.init, alignment.length, numStartConditions=1, estimateSampleTimes=sampling.times.bounds )#
		stopifnot( all(  ph.dated$tip.label == ph$tip.label ) )#
		stopifnot( all( ph.dated$edge == ph$edge ) )#
		#	since the tree topology is unchanged, we can copy#
		#	the branch lenghts in units of time onto the original tree#
		#	that has the ancestral state reconstructions#
		ph$edge.length <- ph.dated$edge.length#
		##
		#	plot dated tree to spot obvious errors#
		##
		outfile <- gsub('workspace\\.rda','annotated_dated_tree.pdf',infile)#
		tmp <- vector('list')#
		tmp[['tree']] <- ph#
		tmp[['tree']][['node.states']] <- tmp[['tree']][['mapped.edge']] <- tmp[['tree']][['maps']] <- NULL#
		attr(tmp[['tree']],'map.order') <- NULL#
		attr(tmp[['tree']],'class') <- 'phylo'#
		tmp[['read.counts']] <- rep(1, Ntip(ph))	#
		write.annotated.tree(tmp, outfile, format="pdf", pdf.scale.bar.width = 0.01, pdf.w = 40, pdf.hm = 0.2, verbose = FALSE)#
		##
		#	save phyloscanner.tree#
		##
		outfile <- gsub('workspace\\.rda','annotated_dated_tree.rda',infile)#
		save(ph, file=outfile)#
	}
require(data.table)#
	require(phangorn)#
	require(ggplot2)#
	require(reshape)#
	require(phyloscannerR)#
	#	working directory with phyloscanner output#
	home <- '/Users/Oliver/Box Sync/OR_Work/Seattle'#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	infiles		<- data.table(F=list.files(indir.phsc, pattern='_annotated_dated_tree.rda$', full.names=TRUE, recursive=TRUE))
infiles
infiles[, SELECT:= gsub('^.*_rerooted_([A-Za-z0-9]+)_.*$','',basename(F))]
infiles
infiles[, SELECT:= gsub('^.*_rerooted_([A-Za-z0-9]+)_.*$','\\1',basename(F))]
infiles
i<- 1#
		cat('process', i,'\n')#
		infile <- infiles[i, F]#
		host <- infiles[i,SELECT]#
		load(infile)
mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]
extract.subgraph
mrcas
stopifnot( any(attr(ph,'class')=='simmap') )#
		# extract subgraphs#
		subgraphs <- lapply(mrcas, function(mrca) extract.subgraph(ph, mrca))
subgraphs
outfile <- gsub('_annotated_dated_tree',paste0('_datedsubgraphs_',host),infile)
outfile
for(i in seq_len(nrow(infiles)))#
	{#
		#i<- 1#
		cat('process', i,'\n')#
		infile <- infiles[i, F]#
		host <- infiles[i,SELECT]#
		load(infile)					#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]	#
		# check that tree is of class simmap#
		stopifnot( any(attr(ph,'class')=='simmap') )#
		# extract subgraphs#
		subgraphs <- lapply(mrcas, function(mrca) extract.subgraph(ph, mrca))#
		# save#
		outfile <- gsub('_annotated_dated_tree',paste0('_datedsubgraphs_',host),infile)#
		save(subgraphs, file=outfile)#
	}
extract.subgraph<- function(ph, mrca)#
{#
	stopifnot( any(class(ph)=='simmap') )#
	stopifnot( c("SPLIT","INDIVIDUAL","BRANCH_COLOURS","SUBGRAPH_MRCA")%in%names(attributes(ph)) )#
	subgraph.name <- as.character(attr(ph, 'SPLIT')[mrca])#
	host <- as.character(attr(ph, "INDIVIDUAL")[mrca])#
	subgraph.root.edge <- ph$edge.length[ which( ph$edge[,2]==mrca ) ]#
	subgraph.parent.state <- as.character(attr(ph, "BRANCH_COLOURS")[ ph$edge[ph$edge[,2]==mrca,1] ])#
	stopifnot( is.na(subgraph.parent.state) || subgraph.parent.state!=host )#
	if(mrca<=Ntip(ph))#
	{#
		subgraph<- list(	edge= matrix(nrow=0, ncol=2), #
				edge.length=vector('numeric',0),#
				Nnode=0,#
				tip.label=ph$tip.label[mrca],#
				maps= vector('list',0),#
				mapped.edge= matrix(nrow=0, ncol=0),#
				node.states= matrix(nrow=0, ncol=2)#
		)#
		#attr(subgraph,'class') <- c( "phylo")#
		#attr(subgraph, "map.order") <- "right-to-left"#
		#attr(subgraph, "order") <- "cladewise"		#
	}#
	if(mrca>Ntip(ph))#
	{#
		subgraph <- phytools:::extract.clade.simmap(ph, mrca)#
		subgraph.root <- Ntip(subgraph)+1L#
		descendants <- Descendants(subgraph, subgraph.root, type='all')#
		tmp <- sapply(descendants, function(x) which(subgraph$edge[,2]==x))#
		descendants.states <- subgraph[['node.states']][tmp,2]#
		descendants.not.in.subgraph <- descendants[ descendants.states!=subgraph.name ]#
		if(length(descendants.not.in.subgraph))#
		{#
			# find all tips of descendants.not.in.subgraph, and remove the corresponding tips, which will remove the subtree for each descendant#
			tips.not.in.subgraph <- sort(unique(unlist(Descendants(subgraph, descendants.not.in.subgraph, type='tips'))))#
			subgraph <- ape:::drop.tip(subgraph, tips.not.in.subgraph)#
			subgraph[['maps']] <- NULL#
			subgraph[['mapped.edge']] <- NULL#
			subgraph[['node.states']] <- NULL#
			attr(subgraph,'class') <- c( "phylo")#
			attr(subgraph, "map.order") <- NULL#
			attr(subgraph, "order") <- NULL#
			attr(subgraph, "SPLIT") <- NULL#
			attr(subgraph, "INDIVIDUAL") <- NULL#
			attr(subgraph, "BRANCH_COLOURS") <- NULL#
			attr(subgraph, "SUBGRAPH_MRCA") <- NULL			#
		}		#
	}#
	subgraph[['subgraph.name']]<- subgraph.name#
	subgraph[['subgraph.root.edge']]<- subgraph.root.edge#
	subgraph[['subgraph.parent.state']]<- subgraph.parent.state#
	subgraph	#
}
for(i in seq_len(nrow(infiles)))#
	{#
		#i<- 1#
		cat('process', i,'\n')#
		infile <- infiles[i, F]#
		host <- infiles[i,SELECT]#
		load(infile)					#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]	#
		# check that tree is of class simmap#
		stopifnot( any(attr(ph,'class')=='simmap') )#
		# extract subgraphs#
		subgraphs <- lapply(mrcas, function(mrca) extract.subgraph(ph, mrca))#
		# save#
		outfile <- gsub('_annotated_dated_tree',paste0('_datedsubgraphs_',host),infile)#
		save(subgraphs, file=outfile)#
	}
traceback()
i<- 4#
		cat('process', i,'\n')#
		infile <- infiles[i, F]#
		host <- infiles[i,SELECT]#
		load(infile)					#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]
mrcas
Ntip(ph)
stopifnot( any(attr(ph,'class')=='simmap') )
mrcas <- na.omit(mrcas)
mrcas
mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]	#
		#	TODO unexpected NA --> needs checking#
		mrcas <- unlist(na.omit(mrcas))
mrcas
mrcas <- as.integer(na.omit(mrcas))
mrcas
for(i in seq_len(nrow(infiles)))#
	{#
		#i<- 4#
		cat('process', i,'\n')#
		infile <- infiles[i, F]#
		host <- infiles[i,SELECT]#
		load(infile)					#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]	#
		#	TODO unexpected NA --> needs checking#
		if(any(is.na(mrcas)))#
			cat('\nFound unexpected NA in mrcas',basename(infile))#
		mrcas <- as.integer(na.omit(mrcas))#
		# check that tree is of class simmap#
		stopifnot( any(attr(ph,'class')=='simmap') )#
		# extract subgraphs#
		subgraphs <- lapply(mrcas, function(mrca) extract.subgraph(ph, mrca))#
		# save#
		outfile <- gsub('_annotated_dated_tree',paste0('_datedsubgraphs_',host),infile)#
		save(subgraphs, file=outfile)#
	}
infiles
subset(infiles, basename(F)!='180709_LANL_SubtypeBc13_mafft_ndrm_000_ft_rerooted_KCMSM__annotated_dated_tree.rda')
infiles <- subset(infiles, basename(F)!='180709_LANL_SubtypeBc13_mafft_ndrm_000_ft_rerooted_KCMSM__annotated_dated_tree.rda')#
	#	extract subgraphs of dated trees#
	for(i in seq_len(nrow(infiles)))#
	{#
		#i<- 4#
		cat('process', i,'\n')#
		infile <- infiles[i, F]#
		host <- infiles[i,SELECT]#
		load(infile)					#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]	#
		#	TODO unexpected NA --> needs checking#
		if(any(is.na(mrcas)))#
			cat('\nFound unexpected NA in mrcas',basename(infile))#
		mrcas <- as.integer(na.omit(mrcas))#
		# check that tree is of class simmap#
		stopifnot( any(attr(ph,'class')=='simmap') )#
		# extract subgraphs#
		subgraphs <- lapply(mrcas, function(mrca) extract.subgraph(ph, mrca))#
		# save#
		outfile <- gsub('_annotated_dated_tree',paste0('_datedsubgraphs_',host),infile)#
		save(subgraphs, file=outfile)#
	}
home <- '/Users/Oliver/Box Sync/OR_Work/Seattle'#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	infiles		<- data.table(F=list.files(indir.phsc, pattern='_annotated_dated_tree.rda$', full.names=TRUE, recursive=TRUE))	#
	infiles[, SELECT:= gsub('^.*_rerooted_([A-Za-z0-9]+)_.*$','\\1',basename(F))]#
	infiles <- subset(infiles, basename(F)!='180709_LANL_SubtypeBc13_mafft_ndrm_000_ft_rerooted_KCMSM__annotated_dated_tree.rda')#
	infiles <- subset(infiles, basename(F)!='180709_LANL_SubtypeBc9_mafft_ndrm_000_ft_rerooted_KC__annotated_dated_tree.rda')#
	#	extract subgraphs of dated trees#
	for(i in seq_len(nrow(infiles)))#
	{#
		#i<- 4#
		cat('process', i,'\n')#
		infile <- infiles[i, F]#
		host <- infiles[i,SELECT]#
		load(infile)					#
		mrcas <- which( attr(ph, 'SUBGRAPH_MRCA') )#
		mrcas <- mrcas[ attr(ph, 'INDIVIDUAL')[mrcas]==host ]	#
		#	TODO unexpected NA --> needs checking#
		if(any(is.na(mrcas)))#
			cat('\nFound unexpected NA in mrcas',basename(infile))#
		mrcas <- as.integer(na.omit(mrcas))#
		# check that tree is of class simmap#
		stopifnot( any(attr(ph,'class')=='simmap') )#
		# extract subgraphs#
		subgraphs <- lapply(mrcas, function(mrca) extract.subgraph(ph, mrca))#
		# save#
		outfile <- gsub('_annotated_dated_tree',paste0('_datedsubgraphs_',host),infile)#
		save(subgraphs, file=outfile)#
	}
~/Box Sync/OR_Work/Seattle/analysis_191017/phyloscanner
home <- '~/Box Sync/OR_Work/Seattle/phyloscanner_out_190723/KCHSX'#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	outdir <- '~/Box Sync/OR_Work/Seattle/analysis_190723/KCHSX'#
	##
	#	extract subgraph taxa	#
	##
	infiles		<- data.table(F=list.files(indir.phsc, pattern='rda$', full.names=TRUE, recursive=TRUE))#
	subset(infiles, grepl('datedsubgraphs',F))
infiles		<- data.table(F=list.files(indir.phsc, pattern='rda$', full.names=TRUE, recursive=TRUE))
infiles
indir.phsc
home <- '~/Box Sync/OR_Work/Seattle'#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	outdir <- '~/Box Sync/OR_Work/Seattle/analysis_190723/KCHSX'#
	##
	#	extract subgraph taxa	#
	##
	infiles		<- data.table(F=list.files(indir.phsc, pattern='rda$', full.names=TRUE, recursive=TRUE))#
	subset(infiles, grepl('datedsubgraphs',F))
infiles[, SELECT:= gsub('^(.*)subgraphs_([A-Z]+)\\.rda','\\2',basename(F))]
infiles
infiles <- subset(infiles, grepl('datedsubgraphs',F))
infiles
infiles[, ST:= gsub('^Subtype(.*)_([0-9]+)_.*\\.rda','\\1',basename(F))]#
	infiles[, REP:= gsub('^Subtype_(.*)_([0-9]+)_.*\\.rda','\\2',basename(F))]
infiles
infiles[, ST:= gsub('^.*Subtype(.*)_([0-9]+)_.*\\.rda','\\1',basename(F))]#
	infiles[, REP:= gsub('^.*Subtype_(.*)_([0-9]+)_.*\\.rda','\\2',basename(F))]
infiles
infiles[, ST:= gsub('^.*Subtype(^_*)_([0-9]+)_.*\\.rda','\\1',basename(F))]#
	infiles[, REP:= gsub('^.*Subtype(^_*)_([0-9]+)_.*\\.rda','\\2',basename(F))]
infiles
infiles[, ST:= gsub('^.*Subtype([^_]+)_([0-9]+)_.*\\.rda','\\1',basename(F))]#
	infiles[, REP:= gsub('^.*Subtype[^_]+)_([0-9]+)_.*\\.rda','\\2',basename(F))]
infiles
infiles[, ST:= gsub('^.*Subtype([^_]+)_.*\\.rda','\\1',basename(F))]
infiles
infiles[, REP:= gsub('^.ndrm_([0-9]+)_.*\\.rda','\\1',basename(F))]
infiles
infiles[, REP:= gsub('^.*ndrm_([0-9]+)_.*\\.rda','\\1',basename(F))]
infiles
dsubgraphtaxa <- infiles[, {#
				#i<- 1#
				#infile <- infiles[i, F]			#
				infile <- F#
				cat('Process',infile,'\n')#
				load(infile)			#
				subgraph.names <- unlist(sapply( subgraphs, function(subgraph)  rep(subgraph$subgraph.name, length(subgraph$tip.label)) ))#
				subgraph.taxa <- unlist(sapply( subgraphs, function(subgraph)  subgraph$tip.label))				#
				list(	NAME=subgraph.names, #
						TAXA= subgraph.taxa #
				)				#
			}, by=c('ST','REP','SELECT')]
dsubgraphtaxa
#	add meta data from taxa names#
	dsubgraphtaxa[, ID:= as.numeric(gsub('^([A-Z]+)_+PR/RT-([0-9]+)-([0-9]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z_]+)-([0-9]+)$','\\3',TAXA))]#
	dsubgraphtaxa[, LOC:= gsub('^([A-Z]+)_+PR/RT-([0-9]+-[0-9]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z_]+)-([0-9]+)$','\\3',TAXA)]#
	dsubgraphtaxa[, ETH:= gsub('^([A-Z]+)_+PR/RT-([0-9]+-[0-9]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z_]+)-([0-9]+)$','\\4',TAXA)]#
	dsubgraphtaxa[, BORN:= gsub('^([A-Z]+)_+PR/RT-([0-9]+-[0-9]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z_]+)-([0-9]+)$','\\5',TAXA)]#
	dsubgraphtaxa[, SEX:= gsub('^([A-Z]+)_+PR/RT-([0-9]+-[0-9]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z_]+)-([0-9]+)$','\\6',TAXA)]#
	dsubgraphtaxa[, TRM:= gsub('_[M|F]','',gsub('^([A-Z]+)_+PR/RT-([0-9]+-[0-9]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z_]+)-([0-9]+)$','\\7',TAXA))]#
	dsubgraphtaxa[, POSDATE:= as.numeric(gsub('^([A-Z]+)_+PR/RT-([0-9]+-[0-9]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z]+)-([a-zA-Z_]+)-([0-9]+)$','\\8',TAXA))]#
	dsubgraphtaxa[, FULL_NAME:= paste0(ST,'_',REP,'_',SELECT,'_',NAME)]
dsubgraphtaxa
regex.tip.label <- '^([A-Z]+)_+PR/RT-([0-9]+)_([0-9]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z_]+)_([0-9]+)$'#
	dsubgraphtaxa[, ID:= as.numeric(gsub(regex.tip.label,'\\3',TAXA))]
dsubgraphtaxa
dsubgraphtaxa[, LOC:= gsub(regex.tip.label,'\\3',TAXA)]#
	dsubgraphtaxa[, ETH:= gsub(regex.tip.label,'\\4',TAXA)]#
	dsubgraphtaxa[, BORN:= gsub(regex.tip.label,'\\5',TAXA)]#
	dsubgraphtaxa[, SEX:= gsub(regex.tip.label,'\\6',TAXA)]#
	dsubgraphtaxa[, TRM:= gsub('_[M|F]','',gsub(regex.tip.label,'\\7',TAXA))]#
	dsubgraphtaxa[, POSDATE:= as.numeric(gsub(regex.tip.label,'\\8',TAXA))]
dsubgraphtaxa
dsubgraphtaxa[, LOC:= gsub(regex.tip.label,'\\5',TAXA)]#
	dsubgraphtaxa[, ETH:= gsub(regex.tip.label,'\\6',TAXA)]
dsubgraphtaxa
dsubgraphtaxa[, LOC:= gsub(regex.tip.label,'\\4',TAXA)]#
	dsubgraphtaxa[, ETH:= gsub(regex.tip.label,'\\5',TAXA)]
dsubgraphtaxa
dsubgraphtaxa[, BORN:= gsub(regex.tip.label,'\\6',TAXA)]#
	dsubgraphtaxa[, SEX:= gsub(regex.tip.label,'\\7',TAXA)]#
	dsubgraphtaxa[, TRM:= gsub('_[M|F]','',gsub(regex.tip.label,'\\8',TAXA))]#
	dsubgraphtaxa[, POSDATE:= as.numeric(gsub(regex.tip.label,'\\9',TAXA))]
dsubgraphtaxa
dsubgraphtaxa[, FULL_NAME:= paste0(ST,'_',REP,'_',SELECT,'_',NAME)]
dsubgraphtaxa
infile.meta <- file.path(home,'PHSKC-2018-07-09','person.rds')
z<- load('~/Box Sync/OR_Work/Seattle/analysis_191017/misc/180709_sequence_labels.rda')
z
dind
require(data.table)#
	require(ape)#
	require(tidyverse)#
	home <- '~/Box Sync/OR_Work/Seattle'#
	infile.indinfo <- file.path(home,'PHSKC-2018-07-09','person.rds')#
	infile.seqinfo <- file.path(home,'PHSKC-2018-07-09','sequences_meta.rds')	#
	infile.countryinfo <- file.path(home,'analysis_191017','misc/Country_db.rds')#
	infiles.lanl <- file.path(home,'analysis_191017','alignments',c('180709_LANL_Subtype01AE_mafft.fasta','180709_LANL_SubtypeA1_mafft.fasta','180709_LANL_SubtypeB_mafft.fasta','180709_LANL_SubtypeC_mafft.fasta'))#
	infile.subtype <- file.path(home,'analysis_191017','misc','180709_Subtype.csv')#
	outfile.base <- file.path(home,'analysis_191017','misc','180709_')#
	##
	# collect country codes#
	##
	dco <- readRDS(infile.countryinfo)#
	dco <- lapply(seq_len(length(dco)), function(i) tibble(WRLD=names(dco)[i], CNTRY=dco[[i]]))#
	dco <- do.call('rbind',dco)#
	dco <- dco %>% mutate(WRLD=gsub('Unkno','Unknown',gsub('\\.|\\_','',WRLD)))	#
	tmp <- tibble(	CNTRY= c("BO", "SD", "EC", "AG", "DM", "GD", "GY", "VC", "SR", "LC", "UZ", "AZ", "GH", "HT", "LV", "BZ", "MN", "GF", "TJ"),#
					NAME= c("Bolivia","Sudan","Ecuador","Antigua","Dominica","Grenada","Guyana","Saint Vincent","Suriname","Saint Lucia","Uzbekistan","Azerbaijan","Ghana","Haiti","Latvia","Belize","Mongolia","French Guiana","Tajikistan"),#
					WRLD= c("SMAm","NorAf","SMAm","SMAm","SMAm","SMAm","SMAm","SMAm","SMAm","SMAm","Asia","Asia","SSA","SMAm","Europe","SMAm","Asia","SMAm","Asia")#
					)#
	dco <- tmp %>%	#
		select(WRLD, CNTRY) %>%			#
		rbind(dco) %>% #
		mutate(WRLD:= case_when(CNTRY=='MX'~"SMAm",CNTRY=='CA'~'Canada',CNTRY=='GL'~'Canada',CNTRY!='GL'&CNTRY!='CA'&CNTRY!='MX'~WRLD)) %>%		#
		arrange(WRLD, CNTRY)#
	table(dco$WRLD, dco$CNTRY)	#
#
	##
	# read Seattle indidivual data #
	#	#
	dind <- readRDS(infile.indinfo) #
	dind <- dind %>% #
			select(newnum, race, b_yr, birthCountry, gender, sex, sex_with_male_and_female, transm, rsh_county_name, rsa_county_name, cur_county_name) %>%#
			mutate( birthCountry2:= gsub('^\\(([A-Z0-9]+)\\).*$','\\1', birthCountry),#
					county:= case_when(	rsh_county_name!="KING CO."&rsa_county_name!="KING CO."&cur_county_name!="KING CO."~'other',#
										rsh_county_name=="KING CO."|rsa_county_name=="KING CO."|cur_county_name=="KING CO."~'king'),#
					Gender2:= case_when(gender=='FM'~'Trns',#
										gender=='MF'~'Trns',#
										gender=='F'&sex=='F'~'F',#
										gender=='F'&sex=='M'~'Trns',#
										gender=='M'&sex=='M'~'M',#
										gender=='M'&sex=='F'~'Trns'),#
					transm2:= case_when(grepl('MSM',transm)~'MSM',#
										grepl('HETERO',transm)~'HSX',#
										grepl('BLOOD|PERINAT|OTHER',transm)~'OTH',#
										grepl('UNKNOWN',transm)~'UNKNOWN'),#
					race2:= case_when( grepl('Black',race)~'Black',#
									grepl('White',race)~'White',#
									grepl('\\(1\\)Hispanic',race)~'Hispanic',#
									grepl('Hawaiian|Indian|Asian|Multi-race',race)~'Other',#
									grepl('Unknown',race)~'Unknown'#
									)) %>%#
			mutate( birthCountry2:= case_when(	birthCountry2==''~'Unknown',#
												birthCountry2=='X98'~'Unknown',#
												birthCountry2=='X99'~'Unknown',#
												birthCountry2!=''&birthCountry2!='X98'&birthCountry2!='X99'~birthCountry2#
												))
dind
dind <- readRDS(infile.indinfo)
dind
dind <- dind %>% #
			select(newnum, race, b_yr, birthCountry, gender, sex, sex_with_male_and_female, transm, rsh_county_name, rsa_county_name, cur_county_name) %>%#
			mutate( birthCountry2:= gsub('^\\(([A-Z0-9]+)\\).*$','\\1', birthCountry),#
					county:= case_when(	rsh_county_name!="KING CO."&rsa_county_name!="KING CO."&cur_county_name!="KING CO."~'other',#
										rsh_county_name=="KING CO."|rsa_county_name=="KING CO."|cur_county_name=="KING CO."~'king'),#
					Gender2:= case_when(gender=='FM'~'Trns',#
										gender=='MF'~'Trns',#
										gender=='F'&sex=='F'~'F',#
										gender=='F'&sex=='M'~'Trns',#
										gender=='M'&sex=='M'~'M',#
										gender=='M'&sex=='F'~'Trns'),#
					transm2:= case_when(grepl('MSM',transm)~'MSM',#
										grepl('HETERO',transm)~'HSX',#
										grepl('BLOOD|PERINAT|OTHER',transm)~'OTH',#
										grepl('UNKNOWN',transm)~'UNKNOWN'),#
					race2:= case_when( grepl('Black',race)~'Black',#
									grepl('White',race)~'White',#
									grepl('\\(1\\)Hispanic',race)~'Hispanic',#
									grepl('Hawaiian|Indian|Asian|Multi-race',race)~'Other',#
									grepl('Unknown',race)~'Unknown'#
									)) %>%#
			mutate( birthCountry2:= case_when(	birthCountry2==''~'Unknown',#
												birthCountry2=='X98'~'Unknown',#
												birthCountry2=='X99'~'Unknown',#
												birthCountry2!=''&birthCountry2!='X98'&birthCountry2!='X99'~birthCountry2#
												))#
	#	setdiff( dind$birthCountry2, dco$CNTRY )	#
	#	let s not resolve country of birth to world region for now..#
	for(x in colnames(dind))#
	 attr(dind[[x]], "label") <- NULL			#
	#			#
	#table(dind$Gender2, dind$transm2, dind$sex_with_male_and_female) # sex_with_male_and_female does not look very reliable#
#
	##
	# read Seattle sequence data #
	#	#
	dseq <- readRDS(infile.seqinfo)#
	dseq <- dseq %>% filter(type=='PR/RT') %>% select(seqID, newnum, seqy)#
	for(x in colnames(dseq))#
		attr(dseq[[x]], "label") <- NULL	#
	dseq <- dind %>% inner_join(dseq, by='newnum')	#
	dseq <- dseq %>% select(newnum, seqID, seqy, county, Gender2, transm2, race2, birthCountry2)	#
	tmp <- as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE)) %>%#
			rename(seqID:=name, ST:=subtype) %>%#
			select(seqID, ST) %>%#
			mutate(seqID= gsub('PRRT','PR/RT',seqID))#
	dseq <- dseq %>% left_join(tmp, by='seqID')#
	##
	#	collect LANL labels#
	##
	dl <- sapply(seq_along(infiles.lanl), function(i) rownames(read.dna(infiles.lanl[i],format='fa')))#
	dl <- tibble(TAXA=unlist(dl)) %>% #
			filter(!grepl('PR\\/RT',TAXA) & TAXA!='HXB2') %>% #
			mutate(	ST:= sapply(strsplit(TAXA,'.',fixed=TRUE),'[[',1),#
					CNTRY:= sapply(strsplit(TAXA,'.',fixed=TRUE),'[[',2),#
					YEAR:= sapply(strsplit(TAXA,'.',fixed=TRUE),'[[',3),#
					GENBANK:= sapply(strsplit(TAXA,'.',fixed=TRUE),'[[',5)) %>% #
			distinct()#
	dl <- dl %>%#
			filter(grepl('HXB2',TAXA)) %>%#
			mutate(TAXA:='HXB2') %>%#
			rbind(dl)	#
	##
	outfile <- paste0(outfile.base,'sequence_labels.rda')#
	save(dseq, dind, dl, dco, file= outfile)
home <- '~/Box Sync/OR_Work/Seattle'#
	infile.indinfo <- file.path(home,'PHSKC-2018-07-09','person.rds')#
	infile.seqinfo <- file.path(home,'PHSKC-2018-07-09','sequences_meta.rds')	#
	infile.countryinfo <- file.path(home,'analysis_191017','misc/Country_db.rds')#
	infiles.lanl <- file.path(home,'analysis_191017','alignments',c('180709_LANL_Subtype01AE_mafft.fasta','180709_LANL_SubtypeA1_mafft.fasta','180709_LANL_SubtypeB_mafft.fasta','180709_LANL_SubtypeC_mafft.fasta'))#
	infile.subtype <- file.path(home,'analysis_191017','misc','180709_Subtype.csv')#
	outfile.base <- file.path(home,'analysis_191017','misc','180709_')#
	##
	# collect country codes#
	##
	dco <- readRDS(infile.countryinfo)#
	dco <- lapply(seq_len(length(dco)), function(i) tibble(WRLD=names(dco)[i], CNTRY=dco[[i]]))#
	dco <- do.call('rbind',dco)#
	dco <- dco %>% mutate(WRLD=gsub('Unkno','Unknown',gsub('\\.|\\_','',WRLD)))	#
	tmp <- tibble(	CNTRY= c("BO", "SD", "EC", "AG", "DM", "GD", "GY", "VC", "SR", "LC", "UZ", "AZ", "GH", "HT", "LV", "BZ", "MN", "GF", "TJ"),#
					NAME= c("Bolivia","Sudan","Ecuador","Antigua","Dominica","Grenada","Guyana","Saint Vincent","Suriname","Saint Lucia","Uzbekistan","Azerbaijan","Ghana","Haiti","Latvia","Belize","Mongolia","French Guiana","Tajikistan"),#
					WRLD= c("SMAm","NorAf","SMAm","SMAm","SMAm","SMAm","SMAm","SMAm","SMAm","SMAm","Asia","Asia","SSA","SMAm","Europe","SMAm","Asia","SMAm","Asia")#
					)#
	dco <- tmp %>%	#
		select(WRLD, CNTRY) %>%			#
		rbind(dco) %>% #
		mutate(WRLD:= case_when(CNTRY=='MX'~"SMAm",CNTRY=='CA'~'Canada',CNTRY=='GL'~'Canada',CNTRY!='GL'&CNTRY!='CA'&CNTRY!='MX'~WRLD)) %>%		#
		arrange(WRLD, CNTRY)#
	table(dco$WRLD, dco$CNTRY)	#
#
	##
	# read Seattle indidivual data #
	#	#
	dind <- readRDS(infile.indinfo) #
	dind <- dind %>% #
			select(newnum, race, b_yr, birthCountry, gender, sex, sex_with_male_and_female, transm, rsh_county_name, rsa_county_name, cur_county_name) %>%#
			mutate( birthCountry2:= gsub('^\\(([A-Z0-9]+)\\).*$','\\1', birthCountry),#
					county:= case_when(	rsh_county_name!="KING CO."&rsa_county_name!="KING CO."&cur_county_name!="KING CO."~'other',#
										rsh_county_name=="KING CO."|rsa_county_name=="KING CO."|cur_county_name=="KING CO."~'king'),#
					Gender2:= case_when(gender=='FM'~'Trns',#
										gender=='MF'~'Trns',#
										gender=='F'&sex=='F'~'F',#
										gender=='F'&sex=='M'~'Trns',#
										gender=='M'&sex=='M'~'M',#
										gender=='M'&sex=='F'~'Trns'),#
					transm2:= case_when(grepl('MSM',transm)~'MSM',#
										grepl('HETERO',transm)~'HSX',#
										grepl('BLOOD|PERINAT|OTHER',transm)~'OTH',#
										grepl('UNKNOWN',transm)~'UNKNOWN'),#
					race2:= case_when( grepl('Black',race)~'Black',#
									grepl('White',race)~'White',#
									grepl('\\(1\\)Hispanic',race)~'Hispanic',#
									grepl('Hawaiian|Indian|Asian|Multi-race',race)~'Other',#
									grepl('Unknown',race)~'Unknown'#
									)) %>%#
			mutate( birthCountry2:= case_when(	birthCountry2==''~'Unknown',#
												birthCountry2=='X98'~'Unknown',#
												birthCountry2=='X99'~'Unknown',#
												birthCountry2!=''&birthCountry2!='X98'&birthCountry2!='X99'~birthCountry2#
												))#
	#	setdiff( dind$birthCountry2, dco$CNTRY )	#
	#	let s not resolve country of birth to world region for now..#
	for(x in colnames(dind))#
	 attr(dind[[x]], "label") <- NULL			#
	#			#
	#table(dind$Gender2, dind$transm2, dind$sex_with_male_and_female) # sex_with_male_and_female does not look very reliable#
#
	##
	# read Seattle sequence data #
	#	#
	dseq <- readRDS(infile.seqinfo)#
	dseq <- dseq %>% filter(type=='PR/RT') %>% select(seqID, newnum, seqy)#
	for(x in colnames(dseq))#
		attr(dseq[[x]], "label") <- NULL	#
	dseq <- dind %>% inner_join(dseq, by='newnum')	#
	dseq <- dseq %>% select(newnum, seqID, seqy, county, Gender2, transm2, race2, birthCountry2)
as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE))
tmp <- as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE)) %>%#
			rename(seqID:=name, ST:=subtype) %>%#
			select(seqID, ST) %>%#
			mutate(seqID= gsub('PRRT','PR/RT',seqID))
as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE)) %>%#
			rename(seqID:=name, ST:=subtype) %>%#
			select(seqID, ST)
as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE)) %>%#
			rename(seqID=name, ST=subtype)
as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE))
require(data.table)#
	require(ape)#
	require(tidyverse)
as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE))
as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE)) %>%#
			rename(seqID=name, ST=subtype)
require(data.table)#
	require(ape)#
	require(tidyverse)#
	home <- '~/Box Sync/OR_Work/Seattle'#
	infile.indinfo <- file.path(home,'PHSKC-2018-07-09','person.rds')#
	infile.seqinfo <- file.path(home,'PHSKC-2018-07-09','sequences_meta.rds')	#
	infile.countryinfo <- file.path(home,'analysis_191017','misc/Country_db.rds')#
	infiles.lanl <- file.path(home,'analysis_191017','alignments',c('180709_LANL_Subtype01AE_mafft.fasta','180709_LANL_SubtypeA1_mafft.fasta','180709_LANL_SubtypeB_mafft.fasta','180709_LANL_SubtypeC_mafft.fasta'))#
	infile.subtype <- file.path(home,'analysis_191017','misc','180709_Subtype.csv')#
	outfile.base <- file.path(home,'analysis_191017','misc','180709_')#
	##
	# collect country codes#
	##
	dco <- readRDS(infile.countryinfo)#
	dco <- lapply(seq_len(length(dco)), function(i) tibble(WRLD=names(dco)[i], CNTRY=dco[[i]]))#
	dco <- do.call('rbind',dco)#
	dco <- dco %>% mutate(WRLD=gsub('Unkno','Unknown',gsub('\\.|\\_','',WRLD)))	#
	tmp <- tibble(	CNTRY= c("BO", "SD", "EC", "AG", "DM", "GD", "GY", "VC", "SR", "LC", "UZ", "AZ", "GH", "HT", "LV", "BZ", "MN", "GF", "TJ"),#
					NAME= c("Bolivia","Sudan","Ecuador","Antigua","Dominica","Grenada","Guyana","Saint Vincent","Suriname","Saint Lucia","Uzbekistan","Azerbaijan","Ghana","Haiti","Latvia","Belize","Mongolia","French Guiana","Tajikistan"),#
					WRLD= c("SMAm","NorAf","SMAm","SMAm","SMAm","SMAm","SMAm","SMAm","SMAm","SMAm","Asia","Asia","SSA","SMAm","Europe","SMAm","Asia","SMAm","Asia")#
					)#
	dco <- tmp %>%	#
		select(WRLD, CNTRY) %>%			#
		rbind(dco) %>% #
		mutate(WRLD:= case_when(CNTRY=='MX'~"SMAm",CNTRY=='CA'~'Canada',CNTRY=='GL'~'Canada',CNTRY!='GL'&CNTRY!='CA'&CNTRY!='MX'~WRLD)) %>%		#
		arrange(WRLD, CNTRY)#
	table(dco$WRLD, dco$CNTRY)	#
#
	##
	# read Seattle indidivual data #
	#	#
	dind <- readRDS(infile.indinfo) #
	dind <- dind %>% #
			select(newnum, race, b_yr, birthCountry, gender, sex, sex_with_male_and_female, transm, rsh_county_name, rsa_county_name, cur_county_name) %>%#
			mutate( birthCountry2:= gsub('^\\(([A-Z0-9]+)\\).*$','\\1', birthCountry),#
					county:= case_when(	rsh_county_name!="KING CO."&rsa_county_name!="KING CO."&cur_county_name!="KING CO."~'other',#
										rsh_county_name=="KING CO."|rsa_county_name=="KING CO."|cur_county_name=="KING CO."~'king'),#
					Gender2:= case_when(gender=='FM'~'Trns',#
										gender=='MF'~'Trns',#
										gender=='F'&sex=='F'~'F',#
										gender=='F'&sex=='M'~'Trns',#
										gender=='M'&sex=='M'~'M',#
										gender=='M'&sex=='F'~'Trns'),#
					transm2:= case_when(grepl('MSM',transm)~'MSM',#
										grepl('HETERO',transm)~'HSX',#
										grepl('BLOOD|PERINAT|OTHER|IDU',transm)~'OTH',#
										grepl('UNKNOWN',transm)~'UNKNOWN'),#
					race2:= case_when( grepl('Black',race)~'Black',#
									grepl('White',race)~'White',#
									grepl('\\(1\\)Hispanic',race)~'Hispanic',#
									grepl('Hawaiian|Indian|Asian|Multi-race',race)~'Other',#
									grepl('Unknown',race)~'Unknown'#
									)) %>%#
			mutate( birthCountry2:= case_when(	birthCountry2==''~'Unknown',#
												birthCountry2=='X98'~'Unknown',#
												birthCountry2=='X99'~'Unknown',#
												birthCountry2!=''&birthCountry2!='X98'&birthCountry2!='X99'~birthCountry2#
												))#
	#	setdiff( dind$birthCountry2, dco$CNTRY )	#
	#	let s not resolve country of birth to world region for now..#
	for(x in colnames(dind))#
	 attr(dind[[x]], "label") <- NULL			#
	#			#
	#table(dind$Gender2, dind$transm2, dind$sex_with_male_and_female) # sex_with_male_and_female does not look very reliable#
#
	##
	# read Seattle sequence data #
	#	#
	dseq <- readRDS(infile.seqinfo)#
	dseq <- dseq %>% filter(type=='PR/RT') %>% select(seqID, newnum, seqy)#
	for(x in colnames(dseq))#
		attr(dseq[[x]], "label") <- NULL	#
	dseq <- dind %>% inner_join(dseq, by='newnum')	#
	dseq <- dseq %>% select(newnum, seqID, seqy, county, Gender2, transm2, race2, birthCountry2)	#
	tmp <- as_tibble(read.csv(infile.subtype, stringsAsFactors=FALSE)) %>%#
			rename(seqID=name, ST=subtype) %>%#
			select(seqID, ST) %>%#
			mutate(seqID= gsub('PRRT','PR/RT',seqID))#
	dseq <- dseq %>% left_join(tmp, by='seqID')#
	##
	#	collect LANL labels#
	##
	dl <- sapply(seq_along(infiles.lanl), function(i) rownames(read.dna(infiles.lanl[i],format='fa')))#
	dl <- tibble(TAXA=unlist(dl)) %>% #
			filter(!grepl('PR\\/RT',TAXA) & TAXA!='HXB2') %>% #
			mutate(	ST:= sapply(strsplit(TAXA,'.',fixed=TRUE),'[[',1),#
					CNTRY:= sapply(strsplit(TAXA,'.',fixed=TRUE),'[[',2),#
					YEAR:= sapply(strsplit(TAXA,'.',fixed=TRUE),'[[',3),#
					GENBANK:= sapply(strsplit(TAXA,'.',fixed=TRUE),'[[',5)) %>% #
			distinct()#
	dl <- dl %>%#
			filter(grepl('HXB2',TAXA)) %>%#
			mutate(TAXA:='HXB2') %>%#
			rbind(dl)	#
	##
	outfile <- paste0(outfile.base,'sequence_labels.rda')#
	save(dseq, dind, dl, dco, file= outfile)
require(data.table)#
	require(phangorn)#
	require(ggplot2)#
	require(reshape)#
	#	working directory with phyloscanner output		#
	home <- '~/Box Sync/OR_Work/Seattle'#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	infile.meta <- file.path(home,'analysis_191017','misc','180709_sequence_labels.rda')#
	outdir <- '~/Box Sync/OR_Work/Seattle/analysis_190723/KCHSX'#
	##
	#	extract subgraph taxa	#
	##
	infiles <- data.table(F=list.files(indir.phsc, pattern='rda$', full.names=TRUE, recursive=TRUE))	#
	infiles <- subset(infiles, grepl('datedsubgraphs',F))#
	infiles[, SELECT:= gsub('^(.*)subgraphs_([A-Z]+)\\.rda','\\2',basename(F))]	#
	infiles[, ST:= gsub('^.*Subtype([^_]+)_.*\\.rda','\\1',basename(F))]#
	infiles[, REP:= gsub('^.*ndrm_([0-9]+)_.*\\.rda','\\1',basename(F))]#
	dsubgraphtaxa <- infiles[, {#
				#i<- 1#
				#infile <- infiles[i, F]			#
				infile <- F#
				cat('Process',infile,'\n')#
				load(infile)			#
				subgraph.names <- unlist(sapply( subgraphs, function(subgraph)  rep(subgraph$subgraph.name, length(subgraph$tip.label)) ))#
				subgraph.taxa <- unlist(sapply( subgraphs, function(subgraph)  subgraph$tip.label))				#
				list(	NAME=subgraph.names, #
						TAXA= subgraph.taxa #
				)				#
			}, by=c('ST','REP','SELECT')]	#
	#	add meta data from taxa names#
	regex.tip.label <- '^([A-Z]+)_+PR/RT-([0-9]+)_([0-9]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z_]+)_([0-9]+)$'#
	dsubgraphtaxa[, ID:= as.numeric(gsub(regex.tip.label,'\\3',TAXA))]	#
	dsubgraphtaxa[, LOC:= gsub(regex.tip.label,'\\4',TAXA)]#
	dsubgraphtaxa[, ETH:= gsub(regex.tip.label,'\\5',TAXA)]#
	dsubgraphtaxa[, BORN:= gsub(regex.tip.label,'\\6',TAXA)]#
	dsubgraphtaxa[, SEX:= gsub(regex.tip.label,'\\7',TAXA)]#
	dsubgraphtaxa[, TRM:= gsub('_[M|F]','',gsub(regex.tip.label,'\\8',TAXA))]#
	dsubgraphtaxa[, POSDATE:= as.numeric(gsub(regex.tip.label,'\\9',TAXA))]#
	dsubgraphtaxa[, FULL_NAME:= paste0(ST,'_',REP,'_',SELECT,'_',NAME)]#
	#	add meta data from persons file	#
	load(infile.meta)#
	dind <- as.data.table(dind)	#
	setnames(dind, c('newnum','b_yr','race2','transm2','Gender2'), c('ID','BIRTH_YEAR2','RACE2','TRANSM2','GENDER2'))#
	tmp <- subset(dind, select=c(ID,BIRTH_YEAR2,RACE2,TRANSM2,GENDER2))#
	set(tmp, NULL, 'BIRTH_YEAR2', tmp[, as.numeric(BIRTH_YEAR2)])#
	dsubgraphtaxa <- merge(dsubgraphtaxa,tmp,by='ID')
subset(dind, ID==65)
dsubgraphtaxa
subset(dsubgraphtaxa, TRANSM2!=TRM
)
subset(dsubgraphtaxa, GENDER2!=SEX)
subset(dsubgraphtaxa, RACE2!=ETH)
load(infile.meta)#
	dind <- as.data.table(dind)
dind
load(infile.meta)#
	dind <- as.data.table(dind)	#
	setnames(dind, c('newnum','b_yr','birthCountry2','race2','transm2','Gender2'), c('ID','BIRTH_YEAR2','BIRTH_COUNTRY2','RACE2','TRANSM2','GENDER2'))#
	tmp <- subset(dind, select=c(ID,BIRTH_YEAR2,BIRTH_COUNTRY2,RACE2,TRANSM2,GENDER2))#
	set(tmp, NULL, 'BIRTH_YEAR2', tmp[, as.numeric(BIRTH_YEAR2)])
tmp
load(infile.meta)#
	dind <- as.data.table(dind)	#
	setnames(dind, c('newnum','b_yr','birthCountry2','county','race2','transm2','Gender2'), c('ID','BIRTH_YEAR2','BIRTH_COUNTRY2','COUNTY','RACE2','TRANSM2','GENDER2'))
dind
infiles <- data.table(F=list.files(indir.phsc, pattern='rda$', full.names=TRUE, recursive=TRUE))	#
	infiles <- subset(infiles, grepl('datedsubgraphs',F))#
	infiles[, SELECT:= gsub('^(.*)subgraphs_([A-Z]+)\\.rda','\\2',basename(F))]	#
	infiles[, ST:= gsub('^.*Subtype([^_]+)_.*\\.rda','\\1',basename(F))]#
	infiles[, REP:= gsub('^.*ndrm_([0-9]+)_.*\\.rda','\\1',basename(F))]#
	dsubgraphtaxa <- infiles[, {#
				#i<- 1#
				#infile <- infiles[i, F]			#
				infile <- F#
				cat('Process',infile,'\n')#
				load(infile)			#
				subgraph.names <- unlist(sapply( subgraphs, function(subgraph)  rep(subgraph$subgraph.name, length(subgraph$tip.label)) ))#
				subgraph.taxa <- unlist(sapply( subgraphs, function(subgraph)  subgraph$tip.label))				#
				list(	NAME=subgraph.names, #
						TAXA= subgraph.taxa #
				)				#
			}, by=c('ST','REP','SELECT')]	#
	#	add meta data from taxa names#
	regex.tip.label <- '^([A-Z]+)_+PR/RT-([0-9]+)_([0-9]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z_]+)_([0-9]+)$'#
	dsubgraphtaxa[, ID:= as.numeric(gsub(regex.tip.label,'\\3',TAXA))]	#
	dsubgraphtaxa[, POSDATE:= as.numeric(gsub(regex.tip.label,'\\9',TAXA))]#
	dsubgraphtaxa[, FULL_NAME:= paste0(ST,'_',REP,'_',SELECT,'_',NAME)]
dsubgraphtaxa
infiles <- data.table(F=list.files(indir.phsc, pattern='rda$', full.names=TRUE, recursive=TRUE))	#
	infiles <- subset(infiles, grepl('datedsubgraphs',F))#
	infiles[, SELECT:= gsub('^(.*)subgraphs_([A-Z]+)\\.rda','\\2',basename(F))]	#
	infiles[, ST:= gsub('^.*Subtype([^_]+)_.*\\.rda','\\1',basename(F))]#
	infiles[, REP:= gsub('^.*ndrm_([0-9]+)_.*\\.rda','\\1',basename(F))]#
	dsubgraphtaxa <- infiles[, {#
				#i<- 1#
				#infile <- infiles[i, F]			#
				infile <- F#
				cat('Process',infile,'\n')#
				load(infile)			#
				subgraph.names <- unlist(sapply( subgraphs, function(subgraph)  rep(subgraph$subgraph.name, length(subgraph$tip.label)) ))#
				subgraph.taxa <- unlist(sapply( subgraphs, function(subgraph)  subgraph$tip.label))				#
				list(	NAME=subgraph.names, #
						TAXA= subgraph.taxa #
				)				#
			}, by=c('ST','REP','SELECT')]	#
	#	add meta data from taxa names#
	regex.tip.label <- '^([A-Z]+)_+PR/RT-([0-9]+)_([0-9]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z_]+)_([0-9]+)$'#
	dsubgraphtaxa[, ID:= as.numeric(gsub(regex.tip.label,'\\3',TAXA))]	#
	dsubgraphtaxa[, SEQ_YEAR:= as.numeric(gsub(regex.tip.label,'\\9',TAXA))]#
	dsubgraphtaxa[, FULL_NAME:= paste0(ST,'_',REP,'_',SELECT,'_',NAME)]
load(infile.meta)#
	dind <- as.data.table(dind)	#
	setnames(dind, c('newnum','b_yr','birthCountry2','county','race2','transm2','Gender2'), c('ID','BIRTH_YEAR2','BIRTH_COUNTRY2','COUNTY','RACE2','TRANSM2','GENDER2'))#
	tmp <- subset(dind, select=c(ID,BIRTH_YEAR2,BIRTH_COUNTRY2,COUNTY,RACE2,TRANSM2,GENDER2))#
	set(tmp, NULL, 'BIRTH_YEAR2', tmp[, as.numeric(BIRTH_YEAR2)])#
	dsubgraphtaxa <- merge(dsubgraphtaxa,tmp,by='ID')#
	dsubgraphtaxa[, AGE2020:= cut(2020-BIRTH_YEAR2, breaks=c(-Inf,20,25,30,35,40,45,50,55,60,Inf))]
dsubgraphtaxa
dsubgraphtaxa[, DUMMY:= RACE2]#
	dcnt <- dsubgraphtaxa[, list(N= length(ID)), by=c('FULL_NAME','DUMMY')]#
	ggplot(dcnt, aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			coord_flip() +#
			labs(y='#individuals',x='phylo subgraphs',fill='ethnicity')
dsubgraphtaxa
infiles[, ST_CLADE:= gsub('c([0-9]+)','\\1',ST)]
infiles
infiles[, ST_CLADE:= gsub('[^c]*c([0-9]+)','\\1',ST)]
infiles
infiles[, ST_CLADE:= as.integer(gsub('[^c]*c([0-9]+)','\\1',ST))]
infiles
infiles[, ST:= gsub('([^c]*)c([0-9]+)','\\1',ST)]
infiles
dsubgraphtaxa <- infiles[, {#
				#i<- 1#
				#infile <- infiles[i, F]			#
				infile <- F#
				cat('Process',infile,'\n')#
				load(infile)			#
				subgraph.names <- unlist(sapply( subgraphs, function(subgraph)  rep(subgraph$subgraph.name, length(subgraph$tip.label)) ))#
				subgraph.taxa <- unlist(sapply( subgraphs, function(subgraph)  subgraph$tip.label))				#
				list(	NAME=subgraph.names, #
						TAXA= subgraph.taxa #
				)				#
			}, by=c('ST','REP','SELECT')]	#
	#	add meta data from taxa names#
	regex.tip.label <- '^([A-Z]+)_+PR/RT-([0-9]+)_([0-9]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z_]+)_([0-9]+)$'#
	dsubgraphtaxa[, ID:= as.numeric(gsub(regex.tip.label,'\\3',TAXA))]	#
	dsubgraphtaxa[, SEQ_YEAR:= as.numeric(gsub(regex.tip.label,'\\9',TAXA))]#
	dsubgraphtaxa[, FULL_NAME:= paste0(ST,'_',REP,'_',SELECT,'_',NAME)]#
	#	add meta data from pre-processed persons file	#
	load(infile.meta)#
	dind <- as.data.table(dind)	#
	setnames(dind, c('newnum','b_yr','birthCountry2','county','race2','transm2','Gender2'), c('ID','BIRTH_YEAR2','BIRTH_COUNTRY2','COUNTY','RACE2','TRANSM2','GENDER2'))#
	tmp <- subset(dind, select=c(ID,BIRTH_YEAR2,BIRTH_COUNTRY2,COUNTY,RACE2,TRANSM2,GENDER2))#
	set(tmp, NULL, 'BIRTH_YEAR2', tmp[, as.numeric(BIRTH_YEAR2)])#
	dsubgraphtaxa <- merge(dsubgraphtaxa,tmp,by='ID')#
	dsubgraphtaxa[, AGE2020:= cut(2020-BIRTH_YEAR2, breaks=c(-Inf,20,25,30,35,40,45,50,55,60,Inf))]
#	working directory with phyloscanner output		#
	home <- '~/Box Sync/OR_Work/Seattle'#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	infile.meta <- file.path(home,'analysis_191017','misc','180709_sequence_labels.rda')#
	outdir <- '~/Box Sync/OR_Work/Seattle/analysis_190723/KCHSX'#
	##
	#	extract subgraph taxa	#
	##
	infiles <- data.table(F=list.files(indir.phsc, pattern='rda$', full.names=TRUE, recursive=TRUE))	#
	infiles <- subset(infiles, grepl('datedsubgraphs',F))#
	infiles[, SELECT:= gsub('^(.*)subgraphs_([A-Z]+)\\.rda','\\2',basename(F))]	#
	infiles[, ST:= gsub('^.*Subtype([^_]+)_.*\\.rda','\\1',basename(F))]#
	infiles[, ST_CLADE:= as.integer(gsub('[^c]*c([0-9]+)','\\1',ST))]#
	infiles[, ST:= gsub('([^c]*)c([0-9]+)','\\1',ST)]#
	infiles[, REP:= gsub('^.*ndrm_([0-9]+)_.*\\.rda','\\1',basename(F))]
infiles
dsubgraphtaxa <- infiles[, {#
				#i<- 1#
				#infile <- infiles[i, F]			#
				infile <- F#
				cat('Process',infile,'\n')#
				load(infile)			#
				subgraph.names <- unlist(sapply( subgraphs, function(subgraph)  rep(subgraph$subgraph.name, length(subgraph$tip.label)) ))#
				subgraph.taxa <- unlist(sapply( subgraphs, function(subgraph)  subgraph$tip.label))				#
				list(	NAME=subgraph.names, #
						TAXA= subgraph.taxa #
				)				#
			}, by=c('ST','ST_CLADE','REP','SELECT')]
regex.tip.label <- '^([A-Z]+)_+PR/RT-([0-9]+)_([0-9]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z_]+)_([0-9]+)$'#
	dsubgraphtaxa[, ID:= as.numeric(gsub(regex.tip.label,'\\3',TAXA))]	#
	dsubgraphtaxa[, SEQ_YEAR:= as.numeric(gsub(regex.tip.label,'\\9',TAXA))]#
	dsubgraphtaxa[, FULL_NAME:= paste0(ST,'_',REP,'_',SELECT,'_',NAME)]#
	#	add meta data from pre-processed persons file	#
	load(infile.meta)#
	dind <- as.data.table(dind)	#
	setnames(dind, c('newnum','b_yr','birthCountry2','county','race2','transm2','Gender2'), c('ID','BIRTH_YEAR2','BIRTH_COUNTRY2','COUNTY','RACE2','TRANSM2','GENDER2'))#
	tmp <- subset(dind, select=c(ID,BIRTH_YEAR2,BIRTH_COUNTRY2,COUNTY,RACE2,TRANSM2,GENDER2))#
	set(tmp, NULL, 'BIRTH_YEAR2', tmp[, as.numeric(BIRTH_YEAR2)])
tmp
dsubgraphtaxa <- merge(dsubgraphtaxa,tmp,by='ID')
dsubgraphtaxa
dsubgraphtaxa[, AGE2020:= cut(2020-BIRTH_YEAR2, breaks=c(-Inf,20,25,30,35,40,45,50,55,60,Inf))]
dsubgraphtaxa
dsubgraphtaxa[, list(SIZE=length(ID)), by=c('ST','REP','SELECT','NAME')]
tmp <- dsubgraphtaxa[, list(SIZE=length(ID)), by=c('ST','REP','SELECT','NAME')]
tmp
dsubgraphsize <- dsubgraphtaxa[, list(SIZE=length(ID)), by=c('ST','REP','SELECT','NAME')]#
	ggplot(dsubgraphsize, aes(x=SIZE, fill=ST)) + #
			geom_bar() + #
			facet_grid(SELECT~.)
ggplot(subset(dsubgraphsize, SELECT!='KC'), aes(x=SIZE, fill=ST)) + #
			geom_bar() + #
			facet_grid(SELECT~.)
ggplot(subset(dsubgraphsize, SELECT!='KC'), aes(x=SIZE, fill=ST)) + #
			geom_bar() + #
			facet_grid(SELECT~.) +#
			labels(x='size of phylogenetic subgraphs attributed to King County/Seattle')
ggplot(subset(dsubgraphsize, SELECT!='KC'), aes(x=SIZE, fill=ST)) + #
			geom_bar() + #
			facet_grid(SELECT~.) +#
			labs(x='size of phylogenetic subgraphs attributed to King County/Seattle')
dsubgraphsize <- dsubgraphtaxa[, list(SIZE=length(ID)), by=c('ST','REP','SELECT','NAME')]#
	ggplot(subset(dsubgraphsize, SELECT!='KC'), aes(x=SIZE, fill=ST)) + #
			geom_bar() + #
			facet_grid(SELECT~.) +#
			labs(x='\nsize of phylogenetic subgraphs attributed to King County/Seattle')
dsubgraphsize
dsubgraphsize[, SINGLETON:= SIZE==1]
dsubgraphsize
dsubgraphsize[, list(N_INDIVIDUALS=sum(SIZE)), by=c('ST','REP','SELECT','SINGLETON')]
dsubgraphind <-  dsubgraphsize[, list(N_INDIVIDUALS=sum(SIZE)), by=c('ST','REP','SELECT','SINGLETON')]
dcast.data.table(dsubgraphind, ST+REP+SINGLETON~SELECT, value.var='N_INDIVIDUALS')
dsubgraphsize[, SINGLETON:= as.character(factor(SIZE==1, levels=c(TRUE,FALSE), labels=c('subgraph size 1','subgraph size >1')))]
dsubgraphind <-  dsubgraphsize[, list(N_INDIVIDUALS=sum(SIZE)), by=c('ST','REP','SELECT','SINGLETON')]
dsubgraphind
dcast.data.table(dsubgraphind, ST+REP+SINGLETON~SELECT, value.var='N_INDIVIDUALS')
dsubgraphind <- dcast.data.table(dsubgraphind, ST+REP+SINGLETON~SELECT, value.var='N_INDIVIDUALS')
dsubgraphind
dsubgraphsize
subset(dsubgraphsize, SIZE>1)
tmp <- subset(dsubgraphsize, SIZE>1, c(ST, REP, SELECT, NAME))
tmp
dsubgraphtaxa2 <- merge(dsubgraphtaxa, tmp, by=c('ST','REP','SELECT','NAME'))
dsubgraphtaxa2
dsubgraphtaxa[, DUMMY:= RACE2]#
	dcnt <- dsubgraphtaxa[, list(N= length(ID)), by=c('FULL_NAME','DUMMY')]#
	ggplot(dcnt, aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			coord_flip() +#
			labs(y='#individuals',x='phylo subgraphs',fill='ethnicity')
dcnt
ggplot(dcnt, aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			coord_flip() +#
			labs(y='#individuals',x='phylo subgraphs',fill='ethnicity') + #
			coord_flip()
ggplot(dcnt, aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='ethnicity')
dsubgraphtaxa[, DUMMY:= BORN]#
	dcnt <- dsubgraphtaxa[, list(N= length(ID)), by=c('FULL_NAME','DUMMY')]#
	ggplot(dcnt, aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='birth place')
dsubgraphtaxa[, DUMMY:= SEX]#
	dcnt <- dsubgraphtaxa[, list(N= length(ID)), by=c('FULL_NAME','DUMMY')]#
	ggplot(dcnt, aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			coord_flip() +#
			labs(y='#individuals',x='phylo subgraphs',fill='sex')
dsubgraphtaxa
dsubgraphtaxa[, DUMMY:= GENDER2]#
	dcnt <- dsubgraphtaxa[, list(N= length(ID)), by=c('FULL_NAME','DUMMY')]#
	ggplot(dcnt, aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			coord_flip() +#
			labs(y='#individuals',x='phylo subgraphs',fill='sex')
dsubgraphtaxa[, DUMMY:= RACE2]#
	dcnt <- dsubgraphtaxa[, list(N= length(ID)), by=c('FULL_NAME','SELECT','DUMMY')]
dcnt
dsubgraphtaxa[, DUMMY:= RACE2]#
	dcnt <- dsubgraphtaxa[, list(N= length(ID)), by=c('FULL_NAME','SELECT','DUMMY')]#
	ggplot(subset(dcnt, SELECT!='KC'), aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='ethnicity') +#
			facet_grid(SELECT~.)
dcnt <- dsubgraphtaxa[, list(N= length(ID)), by=c('FULL_NAME','SELECT','ST','DUMMY')]#
	ggplot(subset(dcnt, SELECT!='KC'), aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='ethnicity') +#
			facet_grid(SELECT~ST)
ggplot(subset(dcnt, SELECT!='KC'), aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='ethnicity') +#
			theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +#
			facet_grid(SELECT~ST, scales='free')
ggplot(subset(dcnt, SELECT!='KC'), aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='ethnicity') +#
			theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +#
			theme_bw() +#
			facet_grid(SELECT~ST, scales='free')
ggplot(subset(dcnt, SELECT!='KC'), aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='ethnicity') +#
			theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +#
			theme_classic() +#
			facet_grid(SELECT~ST, scales='free')
ggplot(subset(dcnt, SELECT!='KC'), aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='ethnicity') +#
			theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +#
			theme_classic() +#
			facet_grid(SELECT~ST)
ggplot(subset(dcnt, SELECT!='KC'), aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='ethnicity') +#
			theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +#
			theme_bw() +#
			facet_grid(SELECT~ST)
ggplot(subset(dcnt, SELECT!='KC'), aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='ethnicity') +#
			theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +#
			facet_grid(SELECT~ST)
dcnt
dcnt <- dsubgraphtaxa[, list(N= length(ID)), by=c('FULL_NAME','SELECT','ST','DUMMY')]#
	tmp <- dsubgraphtaxa[, list(TOTAL= length(ID)), by=c('FULL_NAME','SELECT','ST')]#
	dcnt <- merge(dcnt, tmp, by=c('FULL_NAME','SELECT','ST'))
dcnt
dcnt <- dsubgraphtaxa[, list(N= length(ID)), by=c('FULL_NAME','SELECT','ST','DUMMY')]#
	tmp <- dsubgraphtaxa[, list(TOTAL= length(ID)), by=c('FULL_NAME','SELECT','ST')]#
	dcnt <- merge(dcnt, tmp, by=c('FULL_NAME','SELECT','ST'))#
	dcnt[, list(R= (N/TOTAL)^2), by=c('FULL_NAME','SELECT','ST')]
tmp <- dcnt[, list(R= (N/TOTAL)^2), by=c('FULL_NAME','SELECT','ST')]#
	dcnt <- merge(dcnt, tmp, by=c('FULL_NAME','SELECT','ST'))
dsubgraphtaxa[, DUMMY:= RACE2]#
	dcnt <- dsubgraphtaxa[, list(N= length(ID)), by=c('FULL_NAME','SELECT','ST','DUMMY')]#
	tmp <- dsubgraphtaxa[, list(TOTAL= length(ID)), by=c('FULL_NAME','SELECT','ST')]#
	dcnt <- merge(dcnt, tmp, by=c('FULL_NAME','SELECT','ST'))
dcnt
tmp <- dcnt[, list(R= sum( (N/TOTAL)^2) ), by=c('FULL_NAME','SELECT','ST')]
tmp
tmp[, list(R_AVG=mean(R)), by=c('SELECT')]
dsubgraphtaxa[, DUMMY:= as.character(factor(BIRTH_COUNTRY2=='USA',levels=c(TRUE,FALSE),labels=c('US-born','other')))]#
	dcnt <- dsubgraphtaxa[, list(N= length(ID)), by=c('FULL_NAME','SELECT','ST','DUMMY')]#
	tmp <- dsubgraphtaxa[, list(TOTAL= length(ID)), by=c('FULL_NAME','SELECT','ST')]#
	dcnt <- merge(dcnt, tmp, by=c('FULL_NAME','SELECT','ST'))#
	ggplot(subset(dcnt, SELECT!='KC'), aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='birth place') +#
			theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +#
			facet_grid(SELECT~ST)
tmp <- dcnt[, list(R= sum( (N/TOTAL)^2) ), by=c('FULL_NAME','SELECT','ST')]#
	tmp[, list(R_AVG=mean(R)), by=c('SELECT')]
dsubgraphtaxa[, DUMMY:= AGE2020]#
	dcnt <- dsubgraphtaxa[, list(N= length(ID)), by=c('FULL_NAME','SELECT','ST','DUMMY')]#
	tmp <- dsubgraphtaxa[, list(TOTAL= length(ID)), by=c('FULL_NAME','SELECT','ST')]#
	dcnt <- merge(dcnt, tmp, by=c('FULL_NAME','SELECT','ST'))#
	ggplot(subset(dcnt, SELECT!='KC'), aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='age in 2020') +#
			theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +#
			facet_grid(SELECT~ST)#
	tmp <- dcnt[, list(R= sum( (N/TOTAL)^2) ), by=c('FULL_NAME','SELECT','ST')]#
	tmp[, list(R_AVG=mean(R)), by=c('SELECT')]
dcnt
tmp <- dcnt[, list(R= sum( (N/TOTAL)^2), PMAX= max(N/TOTAL) ), by=c('FULL_NAME','SELECT','ST')]#
	tmp[, list(R_AVG=mean(R), PMAX_AVG=mean(PMAX)), by=c('SELECT')]
dsubgraphtaxa
dsubgraphtaxa2[, DUMMY:= AGE2020]#
	dcnt <- dsubgraphtaxa2[, list(N= length(ID)), by=c('FULL_NAME','SELECT','ST','DUMMY')]#
	tmp <- dsubgraphtaxa2[, list(TOTAL= length(ID)), by=c('FULL_NAME','SELECT','ST')]#
	dcnt <- merge(dcnt, tmp, by=c('FULL_NAME','SELECT','ST'))#
	ggplot(subset(dcnt, SELECT!='KC'), aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='age in 2020') +#
			theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +#
			facet_grid(SELECT~ST)#
	tmp <- dcnt[, list(R= sum( (N/TOTAL)^2), PMAX= max(N/TOTAL) ), by=c('FULL_NAME','SELECT','ST')]#
	tmp[, list(R_AVG=mean(R), PMAX_AVG=mean(PMAX)), by=c('SELECT')]
ggplot(subset(dcnt, SELECT!='KC'), aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='age in 2020') +#
			theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +#
			facet_grid(SELECT~ST, scale='free.x')
ggplot(subset(dcnt, SELECT!='KC'), aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='age in 2020') +#
			theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +#
			facet_grid(SELECT~ST, scales='free.x')
ggplot(subset(dcnt, SELECT!='KC'), aes(x=FULL_NAME, y=N, fill=DUMMY)) +#
			geom_bar(stat='identity') + #
			labs(y='#individuals',x='phylo subgraphs',fill='age in 2020') +#
			theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +#
			facet_grid(SELECT~ST, scale='free_x')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(data.table)#
require(phangorn)#
require(ggplot2)#
require(reshape)#
#
#	working directory with phyloscanner output		#
home <- '~/Box Sync/OR_Work/Seattle'#
indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
#
#	extract subgraph taxa	#
infiles <- data.table(F=list.files(indir.phsc, pattern='rda$', full.names=TRUE, recursive=TRUE))	#
infiles <- subset(infiles, grepl('datedsubgraphs',F))#
#	SELECT defines if KC, KCHSX, KCMSM#
infiles[, SELECT:= gsub('^(.*)subgraphs_([A-Z]+)\\.rda','\\2',basename(F))]#
#	for subtype B, I ran separate analyses based on very large subtrees for comp efficiency#
#	ST stores the subtype, and ST_CLADE the large subtree#
infiles[, ST:= gsub('^.*Subtype([^_]+)_.*\\.rda','\\1',basename(F))]#
infiles[, ST_CLADE:= as.integer(gsub('[^c]*c([0-9]+)','\\1',ST))]#
infiles[, ST:= gsub('([^c]*)c([0-9]+)','\\1',ST)]#
#	ID of bootstrap replicate, 000 for analysis on real alignment#
infiles[, REP:= gsub('^.*ndrm_([0-9]+)_.*\\.rda','\\1',basename(F))]#
dsubgraphtaxa <- infiles[, {#
			#i<- 1#
			#infile <- infiles[i, F]			#
			infile <- F#
			cat('Process',infile,'\n')#
			load(infile)			#
			subgraph.names <- unlist(sapply( subgraphs, function(subgraph)  rep(subgraph$subgraph.name, length(subgraph$tip.label)) ))#
			subgraph.taxa <- unlist(sapply( subgraphs, function(subgraph)  subgraph$tip.label))				#
			list(	NAME=subgraph.names, #
					TAXA= subgraph.taxa #
			)				#
		}, by=c('ST','ST_CLADE','REP','SELECT')]
infile.meta <- file.path(home,'analysis_191017','misc','180709_sequence_labels.rda')#
#
#	add meta data from pre-processed persons file	#
load(infile.meta)#
dind <- as.data.table(dind)	#
setnames(dind, c('newnum','b_yr','birthCountry2','county','race2','transm2','Gender2'), c('ID','BIRTH_YEAR2','BIRTH_COUNTRY2','COUNTY','RACE2','TRANSM2','GENDER2'))#
tmp <- subset(dind, select=c(ID,BIRTH_YEAR2,BIRTH_COUNTRY2,COUNTY,RACE2,TRANSM2,GENDER2))#
set(tmp, NULL, 'BIRTH_YEAR2', tmp[, as.numeric(BIRTH_YEAR2)])#
dsubgraphtaxa <- merge(dsubgraphtaxa,tmp,by='ID')#
dsubgraphtaxa[, AGE2020:= cut(2020-BIRTH_YEAR2, breaks=c(-Inf,20,25,30,35,40,45,50,55,60,Inf))]
home <- '~/Box Sync/OR_Work/Seattle'#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	infile.meta <- file.path(home,'analysis_191017','misc','180709_sequence_labels.rda')#
	outdir <- '~/Box Sync/OR_Work/Seattle/analysis_190723/KCHSX'#
	##
	#	extract subgraph taxa	#
	##
	infiles <- data.table(F=list.files(indir.phsc, pattern='rda$', full.names=TRUE, recursive=TRUE))	#
	infiles <- subset(infiles, grepl('datedsubgraphs',F))#
	#	SELECT defines if KC, KCHSX, KCMSM#
	infiles[, SELECT:= gsub('^(.*)subgraphs_([A-Z]+)\\.rda','\\2',basename(F))]#
	#	for subtype B, I ran separate analyses based on very large subtrees for comp efficiency#
	#	ST stores the subtype, and ST_CLADE the large subtree#
	infiles[, ST:= gsub('^.*Subtype([^_]+)_.*\\.rda','\\1',basename(F))]#
	infiles[, ST_CLADE:= as.integer(gsub('[^c]*c([0-9]+)','\\1',ST))]#
	infiles[, ST:= gsub('([^c]*)c([0-9]+)','\\1',ST)]#
	#	ID of bootstrap replicate, 000 for analysis on real alignment#
	infiles[, REP:= gsub('^.*ndrm_([0-9]+)_.*\\.rda','\\1',basename(F))]#
	dsubgraphtaxa <- infiles[, {#
				#i<- 1#
				#infile <- infiles[i, F]			#
				infile <- F#
				cat('Process',infile,'\n')#
				load(infile)			#
				subgraph.names <- unlist(sapply( subgraphs, function(subgraph)  rep(subgraph$subgraph.name, length(subgraph$tip.label)) ))#
				subgraph.taxa <- unlist(sapply( subgraphs, function(subgraph)  subgraph$tip.label))				#
				list(	NAME=subgraph.names, #
						TAXA= subgraph.taxa #
				)				#
			}, by=c('ST','ST_CLADE','REP','SELECT')]	#
	#	add meta data from taxa names#
	regex.tip.label <- '^([A-Z]+)_+PR/RT-([0-9]+)_([0-9]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z_]+)_([0-9]+)$'#
	dsubgraphtaxa[, ID:= as.numeric(gsub(regex.tip.label,'\\3',TAXA))]	#
	dsubgraphtaxa[, SEQ_YEAR:= as.numeric(gsub(regex.tip.label,'\\9',TAXA))]#
	dsubgraphtaxa[, FULL_NAME:= paste0(ST,'_',REP,'_',SELECT,'_',NAME)]#
	#	add meta data from pre-processed persons file	#
	load(infile.meta)#
	dind <- as.data.table(dind)	#
	setnames(dind, c('newnum','b_yr','birthCountry2','county','race2','transm2','Gender2'), c('ID','BIRTH_YEAR2','BIRTH_COUNTRY2','COUNTY','RACE2','TRANSM2','GENDER2'))#
	tmp <- subset(dind, select=c(ID,BIRTH_YEAR2,BIRTH_COUNTRY2,COUNTY,RACE2,TRANSM2,GENDER2))
tmp
dsubgraphtaxa
set(tmp, NULL, 'BIRTH_YEAR2', tmp[, as.numeric(BIRTH_YEAR2)])
dsubgraphtaxa <- merge(dsubgraphtaxa,tmp,by='ID')
require(data.table)#
require(phangorn)#
require(ggplot2)#
require(reshape)#
#
#	working directory with phyloscanner output		#
home <- '~/Box Sync/OR_Work/Seattle'#
indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
#
#	extract subgraph taxa	#
infiles <- data.table(F=list.files(indir.phsc, pattern='rda$', full.names=TRUE, recursive=TRUE))	#
infiles <- subset(infiles, grepl('datedsubgraphs',F))#
#	SELECT defines if KC, KCHSX, KCMSM#
infiles[, SELECT:= gsub('^(.*)subgraphs_([A-Z]+)\\.rda','\\2',basename(F))]#
#	for subtype B, I ran separate analyses based on very large subtrees for comp efficiency#
#	ST stores the subtype, and ST_CLADE the large subtree#
infiles[, ST:= gsub('^.*Subtype([^_]+)_.*\\.rda','\\1',basename(F))]#
infiles[, ST_CLADE:= as.integer(gsub('[^c]*c([0-9]+)','\\1',ST))]#
infiles[, ST:= gsub('([^c]*)c([0-9]+)','\\1',ST)]#
#	ID of bootstrap replicate, 000 for analysis on real alignment#
infiles[, REP:= gsub('^.*ndrm_([0-9]+)_.*\\.rda','\\1',basename(F))]#
dsubgraphtaxa <- infiles[, {#
			#i<- 1#
			#infile <- infiles[i, F]			#
			infile <- F#
			cat('Process',infile,'\n')#
			load(infile)			#
			subgraph.names <- unlist(sapply( subgraphs, function(subgraph)  rep(subgraph$subgraph.name, length(subgraph$tip.label)) ))#
			subgraph.taxa <- unlist(sapply( subgraphs, function(subgraph)  subgraph$tip.label))				#
			list(	NAME=subgraph.names, #
					TAXA= subgraph.taxa #
			)				#
		}, by=c('ST','ST_CLADE','REP','SELECT')]	#
#	add meta data from taxa names#
regex.tip.label <- '^([A-Z]+)_+PR/RT-([0-9]+)_([0-9]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z]+)_([a-zA-Z_]+)_([0-9]+)$'#
dsubgraphtaxa[, ID:= as.numeric(gsub(regex.tip.label,'\\3',TAXA))]	#
dsubgraphtaxa[, SEQ_YEAR:= as.numeric(gsub(regex.tip.label,'\\9',TAXA))]#
dsubgraphtaxa[, FULL_NAME:= paste0(ST,'_',REP,'_',SELECT,'_',NAME)]
infile.meta <- file.path(home,'analysis_191017','misc','180709_sequence_labels.rda')#
#
#	add meta data from pre-processed persons file	#
load(infile.meta)#
dind <- as.data.table(dind)	#
setnames(dind, c('newnum','b_yr','birthCountry2','county','race2','transm2','Gender2'), c('ID','BIRTH_YEAR2','BIRTH_COUNTRY2','COUNTY','RACE2','TRANSM2','GENDER2'))#
tmp <- subset(dind, select=c(ID,BIRTH_YEAR2,BIRTH_COUNTRY2,COUNTY,RACE2,TRANSM2,GENDER2))#
set(tmp, NULL, 'BIRTH_YEAR2', tmp[, as.numeric(BIRTH_YEAR2)])#
dsubgraphtaxa <- merge(dsubgraphtaxa,tmp,by='ID')#
dsubgraphtaxa[, AGE2020:= cut(2020-BIRTH_YEAR2, breaks=c(-Inf,20,25,30,35,40,45,50,55,60,Inf))]
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(rmarkdown)#
setwd('~/git/hivclust/pkg/misc/vignettes') #
rmarkdown::render('seattle.191017.phyloscanner.subgraphs.Rmd')
require(data.table)#
	require(tidyverse)#
	require(ape)#
	require(phytools)#
	require(treedater)#
	home <- '~/Box Sync/OR_Work/Seattle'#
	infile.seqinfo <- file.path(home,'PHSKC-2018-07-09','sequences_meta.rds')	#
	indir.phsc	<- file.path(home,'analysis_191017','phyloscanner')#
	infiles.phsc <- data.table(F=list.files(indir.phsc, pattern='workspace.rda$', full.names=TRUE, recursive=TRUE))#
	infiles.phsc <- subset(infiles.phsc, grepl('000',F))#
	alignment.length <- 1000#
	##
	# read Seattle sampling data #
	##
	dseq <- readRDS(infile.seqinfo) #
	dseq <- dseq %>% #
			select(seqID, newnum, type, seqy, seqm) %>%#
			mutate( SEQ_DATE:= seqy + (seqm-1)/12 + 15/365,#
					SEQ_DATE_LOWER:= seqy + (seqm-1)/12,#
					SEQ_DATE_UPPER:= seqy + (seqm-1)/12 + 30/365#
					) %>%#
			select(-seqy, -seqm) %>%#
			rename(TAXA= seqID, PID= newnum, TYPE=type)#
	dseq <- as.data.table(dseq)
